<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amber Electric Cost Comparator & Exporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-4xl">
        <header class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-900">Amber Electric Cost Comparator & Exporter</h1>
            <p class="mt-2 text-gray-600">Enter your Amber API key and select a date range to compare costs or export your usage data.</p>
        </header>

        <main>
            <div id="configSection" class="bg-white rounded-lg shadow-md p-6 mb-6">
                <div class="flex justify-between items-center cursor-pointer" id="configHeader">
                    <h2 class="text-lg font-bold text-gray-900">Configuration</h2>
                    <button id="toggleConfigBtn" class="flex items-center text-indigo-600 hover:underline focus:outline-none font-medium">
                        <span class="mr-1">Hide</span>
                        <svg id="configChevron" class="w-5 h-5 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                
                <div id="configContent" class="mt-4 pt-4 border-t">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="md:col-span-2">
                            <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-1">Amber API Key</label>
                            <input type="password" id="apiKey" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="psk_...">
                            <p class="text-xs text-gray-500 mt-1">Your key is stored only in your browser. Find it at <a href="https://app.amber.com.au/developers" target="_blank" class="text-indigo-600 hover:underline">app.amber.com.au/developers</a>.</p>
                        </div>

                         <div class="md:col-span-2 border-t pt-4">
                             <h3 id="otherSupplierHeading" class="block text-base font-medium text-gray-800 mb-2">Other Supplier Details</h3>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <label for="stateSelector" class="block text-sm font-medium text-gray-700 mb-1">State</label>
                                    <select id="stateSelector" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></select>
                                </div>
                                <div>
                                    <label for="planSelector" class="block text-sm font-medium text-gray-700 mb-1">Supplier Plan Templates</label>
                                    <select id="planSelector" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                        <option value="">-- Custom --</option>
                                    </select>
                                </div>
                            </div>
                            <div class="mt-4">
                                <label for="planName" class="block text-sm font-medium text-gray-700 mb-1">Plan Name</label>
                                <input type="text" id="planName" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., Energy Australia TOU 2025">
                            </div>

                             <div class="my-4 pt-4 border-t">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Rate Structure</label>
                                <div class="flex items-center space-x-4" id="rateTypeSelector">
                                    <label class="flex items-center">
                                        <input type="radio" name="rateType" value="flat" class="focus:ring-indigo-500 h-4 w-4 text-indigo-600 border-gray-300" checked>
                                        <span class="ml-2 text-sm text-gray-700">Flat Rate</span>
                                    </label>
                                    <label class="flex items-center">
                                        <input type="radio" name="rateType" value="tou" class="focus:ring-indigo-500 h-4 w-4 text-indigo-600 border-gray-300">
                                        <span class="ml-2 text-sm text-gray-700">Time of Use (TOU)</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="mb-4">
                                <label for="dailyConnectionRate" class="block text-sm font-medium text-gray-700 mb-1">Daily Connection (c/day)</label>
                                <input type="number" id="dailyConnectionRate" value="102.83" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                <p class="text-xs text-gray-500 mt-1">This is a fixed daily service fee.</p>
                            </div>

                            <div id="flatRateSection" class="grid grid-cols-1 sm:grid-cols-2 gap-6">
                                 <div>
                                    <label for="otherSupplierRate" class="block text-sm font-medium text-gray-700 mb-1">General Rate (c/kWh)</label>
                                    <input type="number" id="otherSupplierRate" value="36" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 36">
                                 </div>
                                 <div>
                                    <label for="otherSupplierFeedInRateFlat" class="block text-sm font-medium text-gray-700 mb-1">Feed-in Rate (c/kWh)</label>
                                    <input type="number" id="otherSupplierFeedInRateFlat" value="5" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 5">
                                </div>
                            </div>

                            <div id="touRateSection" class="hidden">
                                <h3 class="text-md font-medium text-gray-800 mt-4 pt-4 border-t border-gray-200 mb-2">Consumption Rates (c/kWh)</h3>
                                <p class="text-xs text-gray-500 mb-3">Rates are based on a standard TOU structure. Weekdays are Mon-Fri.</p>
                                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
                                    <div class="bg-red-50 p-3 rounded-lg border border-red-200">
                                        <label for="tou_peak_rate" class="block text-sm font-medium text-red-700">Peak Rate</label>
                                        <p class="text-xs text-gray-500">2pm - 8pm weekdays</p>
                                        <input type="number" id="tou_peak_rate" value="57.93" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div class="bg-yellow-50 p-3 rounded-lg border border-yellow-200">
                                        <label for="tou_shoulder_rate" class="block text-sm font-medium text-yellow-700">Shoulder Rate</label>
                                        <p class="text-xs text-gray-500">7am-2pm, 8pm-10pm weekdays; 7am-10pm weekends</p>
                                        <input type="number" id="tou_shoulder_rate" value="30.61" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div class="bg-green-50 p-3 rounded-lg border border-green-200">
                                        <label for="tou_offpeak_rate" class="block text-sm font-medium text-green-700">Off-Peak Rate</label>
                                        <p class="text-xs text-gray-500">10pm - 7am every day</p>
                                        <input type="number" id="tou_offpeak_rate" value="24.28" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                                        <label for="tou_controlled_load_rate" class="block text-sm font-medium text-blue-700">Controlled Load</label>
                                        <p class="text-xs text-gray-500">e.g., Hot water</p>
                                        <input type="number" id="tou_controlled_load_rate" value="14.6" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                </div>
                                 <div>
                                    <label for="otherSupplierFeedInRateTou" class="block text-sm font-medium text-gray-700 mb-1">Feed-in Rate (c/kWh)</label>
                                    <input type="number" id="otherSupplierFeedInRateTou" value="4.0" class="w-full max-w-xs px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 5">
                                </div>
                            </div>

                             <div id="demandTariffSection" class="mt-4 pt-4 border-t">
                                <div class="flex items-center mb-2">
                                    <input type="checkbox" id="enableDemandTariff" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                    <label for="enableDemandTariff" class="ml-2 block text-sm font-medium text-gray-800">Enable Demand Tariff for Other Supplier</label>
                                </div>
                                <div id="demandTariffInputs" class="hidden grid grid-cols-1 sm:grid-cols-3 gap-4">
                                    <div>
                                        <label for="demandRate" class="block text-sm font-medium text-gray-700">Demand Rate (c/kW/day)</label>
                                        <input type="number" id="demandRate" value="30" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div>
                                        <label for="demandWindowStart" class="block text-sm font-medium text-gray-700">Window Start</label>
                                        <input type="time" id="demandWindowStart" value="16:00" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div>
                                        <label for="demandWindowEnd" class="block text-sm font-medium text-gray-700">Window End</label>
                                        <input type="time" id="demandWindowEnd" value="21:00" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">Calculates a charge on your highest 30-min usage during the daily window (weekdays only) across the entire period.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 border-t pt-4 mt-4">
                     <div>
                        <label for="startDate" class="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                        <input type="date" id="startDate" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                     <div>
                        <label for="endDate" class="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                        <input type="date" id="endDate" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>


                 <div class="mt-6 text-right">
                    <button id="fetchData" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Compare Costs
                    </button>
                </div>
                                </div>
            </div>

            <div id="messageSection" class="hidden text-center p-6 bg-white rounded-lg shadow-md">
                <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12 mx-auto mb-4 hidden"></div>
                <p id="message" class="text-lg"></p>
                <div id="progressLog" class="text-left text-sm text-gray-600 mt-4 max-h-40 overflow-y-auto bg-gray-50 p-2 rounded"></div>
            </div>

            <div id="resultsSection" class="hidden">
                 <!-- Reordered sections -->
                 <div id="results-output" class="bg-white rounded-lg shadow-md p-6 overflow-x-auto mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl sm:text-2xl font-bold text-gray-900">Comparison Results</h2>
                        <button id="downloadCsvButton" disabled class="bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                            Download CSV
                        </button>
                    </div>
                    <div id="results-table-container"></div>
                 </div>

                 <div id="averageGraphContainer" class="hidden bg-white rounded-lg shadow-md p-6 mb-6 h-[80vh]">
                    <h3 class="text-xl font-bold text-gray-900 mb-4">Average 24-Hour Usage & Price</h3>
                    <canvas id="usagePriceChart"></canvas>
                </div>

                <div id="dailyGraphSection" class="hidden bg-white rounded-lg shadow-md p-6 mb-6">
                    <h3 class="text-xl font-bold text-gray-900 mb-4">Daily Usage & Price Graph</h3>
                    <div class="flex items-center space-x-2 sm:space-x-4 mb-4">
                        <button id="prevDayBtn" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 font-semibold">&lt; Prev</button>
                        <select id="daySelector" class="w-full max-w-xs px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></select>
                        <button id="nextDayBtn" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 font-semibold">Next &gt;</button>
                    </div>
                    <div class="h-[70vh] relative">
                        <canvas id="dailyChart"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Amber Electric Constants (Refactored) ---
        const AMBER_CONNECTION_COST_PER_DAY_CENTS = 109.894;
        const AMBER_SUBSCRIPTION_COST_PER_DAY_CENTS = 72.316;
        const AMBER_DEMAND_TARIFF_COST_PER_KW_CENTS = 42.345;
        const AMBER_API_URL = 'https://api.amber.com.au/v1';

        // --- Global cache for API data ---
        let cachedChannelData = null;
        let lastFetchedStartDate = null;
        let lastFetchedEndDate = null;
        let usageChart = null;
        let dailyUsageChart = null;

        // --- Supplier Templates ---
        const supplierTemplates = {
            "NSW": {
                "EnergyAustralia - Total Plan": { rateType: 'tou', daily: 121.58, peak: 51.55, shoulder: 27.24, offpeak: 20.35, cl: 17.88, feedIn: 7.6, demand: { e: true, r: 33.55, s: '17:00', f: '20:00' } },
                "AGL - Standard": { rateType: 'flat', daily: 102.8, flat: 36.5, feedIn: 5.0, demand: { e: false } },
                "Origin - Go Variable": { rateType: 'tou', daily: 110.0, peak: 55.2, shoulder: 30.1, offpeak: 22.5, cl: 18.0, feedIn: 6.0, demand: { e: false } },
                "Red Energy - Living Energy Saver": { rateType: 'flat', daily: 95.0, flat: 34.2, feedIn: 6.5, demand: { e: false } },
                "OVO Energy - The One Plan": { rateType: 'tou', daily: 105.0, peak: 49.9, shoulder: 25.0, offpeak: 18.9, cl: 16.5, feedIn: 8.0, demand: { e: false } }
            },
            "VIC": {
                "EnergyAustralia - Flexi Plan": { rateType: 'tou', daily: 115.3, peak: 48.9, shoulder: 33.1, offpeak: 24.6, cl: 20.1, feedIn: 4.9, demand: { e: true, r: 29.8, s: '15:00', f: '21:00' } },
                "AGL - Victorian Default Offer": { rateType: 'flat', daily: 120.0, flat: 31.5, feedIn: 4.9, demand: { e: false } },
                "Origin - Basic": { rateType: 'flat', daily: 118.0, flat: 30.8, feedIn: 4.9, demand: { e: false } },
                "Red Energy - Red Wildlife Saver": { rateType: 'tou', daily: 109.0, peak: 45.0, shoulder: 31.0, offpeak: 22.0, cl: 19.5, feedIn: 5.2, demand: { e: false } },
                "Alinta Energy - Home Deal": { rateType: 'flat', daily: 112.5, flat: 29.9, feedIn: 5.2, demand: { e: false } }
            },
            "QLD": {
                "EnergyAustralia - Basic Home": { rateType: 'tou', daily: 130.1, peak: 44.5, shoulder: 24.3, offpeak: 19.8, cl: 18.2, feedIn: 5.0, demand: { e: true, r: 35.1, s: '16:00', f: '21:00' } },
                "AGL - Standard": { rateType: 'flat', daily: 125.6, flat: 28.9, feedIn: 5.0, demand: { e: false } },
                "Origin - Saver": { rateType: 'tou', daily: 122.0, peak: 42.1, shoulder: 23.5, offpeak: 18.9, cl: 17.5, feedIn: 5.0, demand: { e: false } },
                "Alinta Energy - Carbon Neutral": { rateType: 'flat', daily: 119.0, flat: 27.5, feedIn: 5.2, demand: { e: false } },
                "OVO Energy - The One Plan": { rateType: 'flat', daily: 115.0, flat: 26.8, feedIn: 6.0, demand: { e: false } }
            },
            "SA": {
                "EnergyAustralia - Total Plan": { rateType: 'tou', daily: 145.2, peak: 60.1, shoulder: 40.5, offpeak: 30.2, cl: 22.1, feedIn: 6.0, demand: { e: true, r: 40.2, s: '17:00', f: '21:00' } },
                "AGL - Standard": { rateType: 'flat', daily: 138.0, flat: 42.3, feedIn: 6.0, demand: { e: false } },
                "Origin - Go Variable": { rateType: 'tou', daily: 140.0, peak: 58.5, shoulder: 38.9, offpeak: 28.5, cl: 21.0, feedIn: 6.0, demand: { e: false } },
                "Simply Energy - SA Saver": { rateType: 'flat', daily: 135.5, flat: 41.8, feedIn: 6.5, demand: { e: false } },
                "OVO Energy - The One Plan": { rateType: 'flat', daily: 132.0, flat: 40.9, feedIn: 7.0, demand: { e: false } }
            }
        };


        // --- IndexedDB Helper Functions ---
        const DB_NAME = 'AmberDataCacheDB';
        const STORE_NAME = 'dailyUsage';
        const DB_VERSION = 1;

        function openDb() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.error);
                };
            });
        }

        function getUsageData(db, id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => {
                    resolve(event.target.result ? event.target.result.data : null);
                };

                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        function setUsageData(db, id, data) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put({ id, data });

                request.onsuccess = () => {
                    resolve();
                };

                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }


        const formatForInput = (date) => {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        // Convert a Date object to a local ISO-like string with timezone offset (no milliseconds)
        // e.g. "2025-08-02T23:55:00+10:00"
        function toLocalIsoWithOffset(d) {
            function pad(n) { return String(n).padStart(2, '0'); }
            const year = d.getFullYear();
            const month = pad(d.getMonth() + 1);
            const day = pad(d.getDate());
            const hours = pad(d.getHours());
            const minutes = pad(d.getMinutes());
            const seconds = pad(d.getSeconds());

            // timezone offset in minutes, positive if local time is behind UTC (so we invert sign)
            const offsetMinutes = -d.getTimezoneOffset();
            const sign = offsetMinutes >= 0 ? '+' : '-';
            const absOffset = Math.abs(offsetMinutes);
            const offsetHours = pad(Math.floor(absOffset / 60));
            const offsetMins = pad(absOffset % 60);

            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${offsetHours}:${offsetMins}`;
        }

        // --- Event Listeners and Initial Setup ---
        window.addEventListener('DOMContentLoaded', () => {
            // --- Config Section Toggle ---
            const configHeader = document.getElementById('configHeader');
            const toggleConfigBtn = document.getElementById('toggleConfigBtn');
            const configContent = document.getElementById('configContent');
            const configChevron = document.getElementById('configChevron');

            const updateConfigVisibility = (isHidden, animate = true) => {
                if(animate){
                    configContent.classList.add('transition-all', 'duration-300', 'ease-in-out');
                } else {
                    configContent.classList.remove('transition-all', 'duration-300', 'ease-in-out');
                }

                if (isHidden) {
                    configContent.classList.add('hidden');
                    toggleConfigBtn.querySelector('span').textContent = 'Show';
                    configChevron.style.transform = 'rotate(-180deg)';
                } else {
                    configContent.classList.remove('hidden');
                    toggleConfigBtn.querySelector('span').textContent = 'Hide';
                    configChevron.style.transform = 'rotate(0deg)';
                }
            };

            const isConfigHidden = localStorage.getItem('configHidden') === 'true';
            updateConfigVisibility(isConfigHidden, false); 

            const toggleHandler = () => {
                const isCurrentlyHidden = configContent.classList.contains('hidden');
                updateConfigVisibility(!isCurrentlyHidden);
                localStorage.setItem('configHidden', !isCurrentlyHidden);
            };

            configHeader.addEventListener('click', toggleHandler);

            // --- Load Saved Settings ---
            const apiKeyInput = document.getElementById('apiKey');
            const savedApiKey = localStorage.getItem('amberApiKey');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
            }

            Chart.Tooltip.positioners.cursor = function(items, eventPosition) {
                return eventPosition;
            };

            // --- Custom Chart.js Plugin to Highlight Hovered Column ---
            const verticalHighlightPlugin = {
                id: 'verticalHighlight',
                beforeDatasetsDraw: (chart) => {
                    // Use the public method to get active elements.
                    const activeElements = chart.tooltip?.getActiveElements();
                    if (activeElements && activeElements.length > 0) {
                        const ctx = chart.ctx;
                        const activeElement = activeElements[0];
                        const index = activeElement.index;
                        const xAxis = chart.scales.x;
                        
                        // Proceed only if the scale and index are valid
                        if (xAxis && index !== undefined) {
                            const x = xAxis.getPixelForValue(index);
                            const topY = chart.chartArea.top;
                            const bottomY = chart.chartArea.bottom;
                            
                            // Calculate the width of one category on the x-axis.
                            // This is more reliable than using ticks.
                            const categoryWidth = xAxis.getPixelForValue(1) - xAxis.getPixelForValue(0);

                            ctx.save();
                            ctx.fillStyle = 'rgba(220, 220, 220, 0.4)';
                            // Draw the rectangle, offsetting by half the width to center it on the category.
                            ctx.fillRect(x - categoryWidth / 2, topY, categoryWidth, bottomY - topY);
                            ctx.restore();
                        }
                    }
                }
            };
            Chart.register(verticalHighlightPlugin);


            const endDateInput = document.getElementById('endDate');
            const startDateInput = document.getElementById('startDate');
            
            const savedStartDate = localStorage.getItem('startDate');
            const savedEndDate = localStorage.getItem('endDate');
            
            const today = new Date();
            const maxDate = formatForInput(today);
            startDateInput.setAttribute('max', maxDate);

            if (savedStartDate && savedEndDate) {
                startDateInput.value = savedStartDate;
                endDateInput.value = savedEndDate;
            } else {
                const now = new Date();
                const firstDayOfCurrentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                const lastDayOfCurrentMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);

                startDateInput.value = formatForInput(firstDayOfCurrentMonth);
                endDateInput.value = formatForInput(lastDayOfCurrentMonth);
            }


            const rateTypeSelector = document.getElementById('rateTypeSelector');
            const flatRateSection = document.getElementById('flatRateSection');
            const touRateSection = document.getElementById('touRateSection');
            
            // --- NEW: Template Selectors ---
            const stateSelector = document.getElementById('stateSelector');
            const planSelector = document.getElementById('planSelector');
            const planNameInput = document.getElementById('planName');

            // --- NEW: Demand Tariff Elements ---
            const enableDemandCheckbox = document.getElementById('enableDemandTariff');
            const demandInputsDiv = document.getElementById('demandTariffInputs');
            
            // Populate States
            Object.keys(supplierTemplates).forEach(state => {
                const option = document.createElement('option');
                option.value = state;
                option.textContent = state;
                stateSelector.appendChild(option);
            });
            
            function updatePlanSelector(selectedState) {
                planSelector.innerHTML = '<option value="">-- Custom --</option>';
                if (supplierTemplates[selectedState]) {
                    Object.keys(supplierTemplates[selectedState]).forEach(planName => {
                        const option = document.createElement('option');
                        option.value = planName;
                        option.textContent = planName;
                        planSelector.appendChild(option);
                    });
                }
            }
            
            function applyPlanTemplate() {
                const state = stateSelector.value;
                const planName = planSelector.value;
                if (!state || !planName) return;

                const template = supplierTemplates[state][planName];
                if (!template) return;
                
                planNameInput.value = planName;
                updateOtherSupplierHeading();

                // Set Rate Type
                document.querySelector(`input[name="rateType"][value="${template.rateType}"]`).checked = true;
                if (template.rateType === 'tou') {
                    flatRateSection.classList.add('hidden');
                    touRateSection.classList.remove('hidden');
                    document.getElementById('tou_peak_rate').value = template.peak || 0;
                    document.getElementById('tou_shoulder_rate').value = template.shoulder || 0;
                    document.getElementById('tou_offpeak_rate').value = template.offpeak || 0;
                    document.getElementById('tou_controlled_load_rate').value = template.cl || 0;
                    document.getElementById('otherSupplierFeedInRateTou').value = template.feedIn || 0;
                } else {
                    flatRateSection.classList.remove('hidden');
                    touRateSection.classList.add('hidden');
                    document.getElementById('otherSupplierRate').value = template.flat || 0;
                    document.getElementById('otherSupplierFeedInRateFlat').value = template.feedIn || 0;
                }
                
                document.getElementById('dailyConnectionRate').value = template.daily || 0;
                
                // Set Demand Tariff
                const demand = template.demand || { e: false };
                enableDemandCheckbox.checked = demand.e;
                if (demand.e) {
                    demandInputsDiv.classList.remove('hidden');
                    document.getElementById('demandRate').value = demand.r || 0;
                    document.getElementById('demandWindowStart').value = demand.s || '16:00';
                    document.getElementById('demandWindowEnd').value = demand.f || '21:00';
                } else {
                    demandInputsDiv.classList.add('hidden');
                }
                
                // Save all settings after applying
                saveAllSettings();
            }
            
            function updateOtherSupplierHeading() {
                const heading = document.getElementById('otherSupplierHeading');
                const planName = planNameInput.value.trim();
                heading.textContent = planName ? `${planName} Details` : 'Other Supplier Details';
            }
            
            // --- Save All Settings ---
            function saveAllSettings() {
                localStorage.setItem('rateType', document.querySelector('input[name="rateType"]:checked').value);
                localStorage.setItem('flatRate', document.getElementById('otherSupplierRate').value);
                localStorage.setItem('flatFeedInRate', document.getElementById('otherSupplierFeedInRateFlat').value);
                localStorage.setItem('dailyConnectionRate', document.getElementById('dailyConnectionRate').value);
                
                const touRates = {
                    peak: document.getElementById('tou_peak_rate').value,
                    shoulder: document.getElementById('tou_shoulder_rate').value,
                    offpeak: document.getElementById('tou_offpeak_rate').value,
                    controlledLoad: document.getElementById('tou_controlled_load_rate').value,
                    feedIn: document.getElementById('otherSupplierFeedInRateTou').value
                };
                localStorage.setItem('touRates', JSON.stringify(touRates));
                
                localStorage.setItem('selectedState', stateSelector.value);
                localStorage.setItem('selectedPlan', planSelector.value);
                localStorage.setItem('planName', planNameInput.value);
                
                const demandSettings = {
                    enabled: enableDemandCheckbox.checked,
                    rate: document.getElementById('demandRate').value,
                    start: document.getElementById('demandWindowStart').value,
                    end: document.getElementById('demandWindowEnd').value,
                };
                localStorage.setItem('demandSettings', JSON.stringify(demandSettings));
            }
            
            // --- Load All Settings ---
            function loadAllSettings() {
                const savedState = localStorage.getItem('selectedState') || 'NSW';
                stateSelector.value = savedState;
                updatePlanSelector(savedState);
                
                const savedPlan = localStorage.getItem('selectedPlan');
                if(savedPlan) planSelector.value = savedPlan;
                
                const savedPlanName = localStorage.getItem('planName');
                if(savedPlanName) {
                    planNameInput.value = savedPlanName;
                    updateOtherSupplierHeading();
                }

                const savedRateType = localStorage.getItem('rateType');
                if (savedRateType) {
                    document.querySelector(`input[name="rateType"][value="${savedRateType}"]`).checked = true;
                    if (savedRateType === 'tou') {
                        flatRateSection.classList.add('hidden');
                        touRateSection.classList.remove('hidden');
                    } else {
                        flatRateSection.classList.remove('hidden');
                        touRateSection.classList.add('hidden');
                    }
                }
                
                const savedFlatRate = localStorage.getItem('flatRate');
                if (savedFlatRate) document.getElementById('otherSupplierRate').value = savedFlatRate;
                
                const savedFlatFeedIn = localStorage.getItem('flatFeedInRate');
                if (savedFlatFeedIn) document.getElementById('otherSupplierFeedInRateFlat').value = savedFlatFeedIn;
                
                const savedTouRates = localStorage.getItem('touRates');
                if (savedTouRates) {
                    const rates = JSON.parse(savedTouRates);
                    document.getElementById('tou_peak_rate').value = rates.peak;
                    document.getElementById('tou_shoulder_rate').value = rates.shoulder;
                    document.getElementById('tou_offpeak_rate').value = rates.offpeak;
                    document.getElementById('tou_controlled_load_rate').value = rates.controlledLoad;
                    document.getElementById('otherSupplierFeedInRateTou').value = rates.feedIn;
                }

                const savedDailyConnectionRate = localStorage.getItem('dailyConnectionRate');
                if (savedDailyConnectionRate) {
                    document.getElementById('dailyConnectionRate').value = savedDailyConnectionRate;
                }
                
                const savedDemandSettings = localStorage.getItem('demandSettings');
                if (savedDemandSettings) {
                    const settings = JSON.parse(savedDemandSettings);
                    enableDemandCheckbox.checked = settings.enabled;
                    document.getElementById('demandRate').value = settings.rate;
                    document.getElementById('demandWindowStart').value = settings.start;
                    document.getElementById('demandWindowEnd').value = settings.end;
                    if (settings.enabled) {
                        demandInputsDiv.classList.remove('hidden');
                    }
                }
            }
            
            loadAllSettings();
            
            // --- ADD EVENT LISTENERS ---
            stateSelector.addEventListener('change', (e) => {
                updatePlanSelector(e.target.value);
                localStorage.setItem('selectedState', e.target.value);
                planSelector.value = ''; // Reset plan selection
            });
            planSelector.addEventListener('change', applyPlanTemplate);
            planNameInput.addEventListener('input', () => {
                updateOtherSupplierHeading();
                saveAllSettings();
            });

            // Toggle demand tariff inputs
            enableDemandCheckbox.addEventListener('change', (e) => {
                demandInputsDiv.classList.toggle('hidden', !e.target.checked);
                saveAllSettings();
            });

            // Add listeners to save all settings on any change
            document.querySelectorAll('#configContent input, #configContent select').forEach(el => {
                if (el.id !== 'stateSelector' && el.id !== 'planSelector' && el.id !== 'planName') {
                     el.addEventListener('input', saveAllSettings);
                }
            });
            rateTypeSelector.addEventListener('change', saveAllSettings);


            document.getElementById('downloadCsvButton').addEventListener('click', generateAndDownloadCSV);
        });

        // --- Main Fetch and Calculation Logic ---
        document.getElementById('fetchData').addEventListener('click', async () => {
            const resultsSection = document.getElementById('resultsSection');
            const messageSection = document.getElementById('messageSection');
            const messageEl = document.getElementById('message');
            const loader = document.getElementById('loader');
            const progressLog = document.getElementById('progressLog');
            const resultsOutput = document.getElementById('results-output');
            const downloadCsvButton = document.getElementById('downloadCsvButton');
            const averageGraphContainer = document.getElementById('averageGraphContainer');
            const dailyGraphSection = document.getElementById('dailyGraphSection');

            resultsSection.classList.add('hidden');
            averageGraphContainer.classList.add('hidden');
            dailyGraphSection.classList.add('hidden');
            downloadCsvButton.disabled = true;
            document.getElementById('results-table-container').innerHTML = '';
            messageEl.textContent = '';
            progressLog.innerHTML = '';
            
            if (dailyUsageChart) { dailyUsageChart.destroy(); dailyUsageChart = null; }


            const apiKey = document.getElementById('apiKey').value;
            const startDateValue = document.getElementById('startDate').value;
            const endDateValue = document.getElementById('endDate').value;
            
            // Store the dates in localStorage for next time
            localStorage.setItem('startDate', startDateValue);
            localStorage.setItem('endDate', endDateValue);
            
            if (!apiKey) {
                messageSection.classList.remove('hidden');
                messageEl.textContent = 'Please enter your Amber API key.';
                return;
            }
            
            localStorage.setItem('amberApiKey', apiKey);

             if (!startDateValue || !endDateValue) {
                messageSection.classList.remove('hidden');
                messageEl.textContent = 'Please select a start and end date.';
                return;
            }
            // Parse date strings as local time by appending T00:00:00
            const overallStartDate = new Date(startDateValue + 'T00:00:00');
            let overallEndDate = new Date(endDateValue + 'T00:00:00');
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // If the user selected a future date, silently cap it to today for calculations.
            if (overallEndDate > today) {
                overallEndDate = today;
            }
            
            overallEndDate.setHours(23, 59, 59, 999); // Ensure the entire end day is included

            if (overallEndDate < overallStartDate) {
                messageSection.classList.remove('hidden');
                messageEl.textContent = 'End date cannot be before the start date.';
                return;
            }
            const numDays = Math.ceil((overallEndDate - overallStartDate) / (1000 * 60 * 60 * 24));

            if (cachedChannelData && startDateValue === lastFetchedStartDate && endDateValue === lastFetchedEndDate) {
                messageSection.classList.remove('hidden');
                loader.classList.add('hidden');
                messageEl.textContent = 'Recalculating with new rates...';
                
                setTimeout(() => {
                    const amberDailyCosts = (AMBER_CONNECTION_COST_PER_DAY_CENTS + AMBER_SUBSCRIPTION_COST_PER_DAY_CENTS) * numDays;
                    const otherDailyConnection = (parseFloat(document.getElementById('dailyConnectionRate').value) || 0) * numDays;
                    
                    const otherDemandTariffInfo = calculateOtherDemandTariff(cachedChannelData, numDays);
                    calculateOtherSupplierCosts(cachedChannelData, otherDemandTariffInfo.cost);
                    
                    const demandTariffInfo = calculateDemandTariff(cachedChannelData);
                    const demandTariffCost = demandTariffInfo.cost;

                    let overallAmberCost = 0;
                    let overallOtherCost = 0;

                    Object.values(cachedChannelData).forEach(c => {
                        overallAmberCost += c.totalAmberCost;
                        overallOtherCost += c.totalOtherCost;
                    });
                    
                    overallAmberCost += (demandTariffCost + amberDailyCosts / 100);
                    overallOtherCost += otherDailyConnection / 100;

                    messageSection.classList.add('hidden');
                    resultsSection.classList.remove('hidden');
                    displayResults(cachedChannelData, overallAmberCost, overallOtherCost, startDateValue, endDateValue, numDays, demandTariffInfo, otherDemandTariffInfo);
                }, 200);

                return;
            }

            cachedChannelData = null;

            messageSection.classList.remove('hidden');
            loader.classList.remove('hidden');
            
            const headers = { 'Authorization': `Bearer ${apiKey}`, 'accept': 'application/json' };

            try {
                messageEl.textContent = 'Fetching your site details...';
                const sitesResponse = await fetch(`${AMBER_API_URL}/sites`, { headers });
                 if (!sitesResponse.ok) {
                    if (sitesResponse.status === 403) {
                        throw new Error(`Authentication failed. Your API Key appears to be invalid. Please check and try again.`);
                    }
                    let detail = `Status: ${sitesResponse.status} ${sitesResponse.statusText}`;
                    try { const errorText = await sitesResponse.text(); detail = JSON.parse(errorText).message || errorText; } catch (e) { /* ignore */ }
                    throw new Error(`Failed to fetch sites. ${detail}`);
                }
                const sites = await sitesResponse.json();
                if (!sites || sites.length === 0) throw new Error('No sites found for this API key.');
                
                const site = sites[0];
                const siteId = site.id;
                const channels = site.channels;
                if (!channels || channels.length === 0) throw new Error('No channels found for this site.');

                messageEl.textContent = `Site found: ${siteId}. Preparing to fetch usage data...`;
                
                let channelTotals = {};
                channels.forEach(c => {
                    channelTotals[c.identifier] = {
                        identifier: c.identifier,
                        type: c.type,
                        totalKWh: 0,
                        totalAmberCost: 0,
                        totalCents: 0, 
                        count: 0, 
                        usageData: []
                    };
                });
                
                // --- NEW IndexedDB CACHING AND FETCHING LOGIC ---
                const db = await openDb();
                const allUsageData = [];
                let datesToFetch = [];

                const cacheBoundary = new Date();
                cacheBoundary.setHours(0, 0, 0, 0);
                cacheBoundary.setDate(cacheBoundary.getDate() - 3);

                let currentDate = new Date(overallStartDate);
                while (currentDate <= overallEndDate) {
                    const dateStr = formatForInput(currentDate);
                    if (currentDate >= cacheBoundary) {
                        datesToFetch.push(dateStr);
                    } else {
                        const cacheKey = `${siteId}_${dateStr}`;
                        const cachedDayData = await getUsageData(db, cacheKey);
                        if (cachedDayData) {
                            progressLog.innerHTML += `<div>${dateStr} - cached</div>`;
                            allUsageData.push(...cachedDayData);
                        } else {
                            datesToFetch.push(dateStr);
                        }
                    }
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                // Consolidate dates to fetch into ranges of max 7 days to minimize API calls
                const fetchRanges = [];
                if (datesToFetch.length > 0) {
                    let rangeStart = datesToFetch[0];
                    let rangeEnd = datesToFetch[0];

                    const getDaysBetween = (start, end) => {
                        const startDate = new Date(start + 'T00:00:00');
                        const endDate = new Date(end + 'T00:00:00');
                        // +1 because the range is inclusive
                        return Math.round((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                    };

                    for (let i = 1; i < datesToFetch.length; i++) {
                        const nextDay = new Date(rangeEnd + 'T00:00:00');
                        nextDay.setDate(nextDay.getDate() + 1);

                        // If the current date is consecutive AND the range is less than 7 days
                        if (datesToFetch[i] === formatForInput(nextDay) && getDaysBetween(rangeStart, rangeEnd) < 7) {
                            rangeEnd = datesToFetch[i];
                        } else {
                            fetchRanges.push({ start: rangeStart, end: rangeEnd });
                            rangeStart = datesToFetch[i];
                            rangeEnd = datesToFetch[i];
                        }
                    }
                    fetchRanges.push({ start: rangeStart, end: rangeEnd });
                }

                for (const range of fetchRanges) {
                    messageEl.textContent = `Fetching data from API...`;
                    progressLog.innerHTML += `<div>${range.start} to ${range.end} - API load</div>`;

                    const usageUrl = `${AMBER_API_URL}/sites/${siteId}/usage?startDate=${range.start}&endDate=${range.end}`;
                    const usageResponse = await fetch(usageUrl, { headers });
                    const responseText = await usageResponse.text();

                    if (!usageResponse.ok) {
                        let detail = responseText;
                        try { detail = (JSON.parse(responseText)).message || responseText; } catch (e) { /* not JSON */ }
                        throw new Error(`Failed to fetch usage for ${range.start} to ${range.end}. Status: ${usageResponse.status}. Message: ${detail}`);
                    }
                    
                    const apiResponseData = JSON.parse(responseText);
                    allUsageData.push(...apiResponseData);

                    // Group by day to store in cache
                    const dailyData = {};
                    apiResponseData.forEach(item => {
                        const itemDate = new Date(item.nemTime);
                        // Subtract 1 second to correctly handle the midnight boundary.
                        // An interval ending at 00:00:00 belongs to the previous day.
                        itemDate.setSeconds(itemDate.getSeconds() - 1);
                        
                        // Use local date for grouping, to align with the requested date range.
                        const usageDateStr = formatForInput(itemDate);

                        // Only cache data that falls within the requested fetch range.
                        // This prevents an extra interval from the API (e.g., 00:05 on the next day)
                        // from overwriting a valid day's cache with incomplete data.
                        if (usageDateStr >= range.start && usageDateStr <= range.end) {
                            if (!dailyData[usageDateStr]) {
                                dailyData[usageDateStr] = [];
                            }
                            dailyData[usageDateStr].push(item);
                        }
                    });


                    for (const dateStr in dailyData) {
                        const dayDate = new Date(dateStr + 'T00:00:00');
                        if (dayDate < cacheBoundary) {
                            const cacheKey = `${siteId}_${dateStr}`;
                            await setUsageData(db, cacheKey, dailyData[dateStr]);
                        }
                    }
                }
                
                if (allUsageData && allUsageData.length > 0) {
                    allUsageData.forEach(item => {
                        const itemDate = new Date(item.nemTime);
                        itemDate.setMinutes(itemDate.getMinutes() - 5);
                        item.nemTime = toLocalIsoWithOffset(itemDate);

                        const channelId = item.channelIdentifier;
                        if (!channelTotals[channelId]) return;
                        
                        const channelData = channelTotals[channelId];
                        const kwh = parseFloat(item.kwh) || 0;
                        const perKwh = parseFloat(item.perKwh) || 0;
                        channelData.totalKWh += kwh;
                        channelData.totalAmberCost += (perKwh / 100) * kwh;
                        channelData.usageData.push(item);
                        channelData.totalCents += perKwh;
                        channelData.count += 1;
                    });
                }
                
                // Sort all usage data by date after fetching is complete
                Object.values(channelTotals).forEach(c => {
                    c.usageData.sort((a, b) => new Date(a.nemTime) - new Date(b.nemTime));
                });
                
                messageEl.textContent = 'Calculating costs...';
                
                const otherDemandTariffInfo = calculateOtherDemandTariff(channelTotals, numDays);
                calculateOtherSupplierCosts(channelTotals, otherDemandTariffInfo.cost);

                lastFetchedStartDate = startDateValue;
                lastFetchedEndDate = endDateValue;
                cachedChannelData = JSON.parse(JSON.stringify(channelTotals));
                
                const amberDailyCosts = (AMBER_CONNECTION_COST_PER_DAY_CENTS + AMBER_SUBSCRIPTION_COST_PER_DAY_CENTS) * numDays;
                const otherDailyConnection = (parseFloat(document.getElementById('dailyConnectionRate').value) || 0) * numDays;

                const demandTariffInfo = calculateDemandTariff(cachedChannelData);
                const demandTariffCost = demandTariffInfo.cost;
                
                let overallAmberCost = 0;
                let overallOtherCost = 0;

                Object.values(cachedChannelData).forEach(c => {
                    overallAmberCost += c.totalAmberCost;
                    overallOtherCost += c.totalOtherCost;
                });

                overallAmberCost += (demandTariffCost + amberDailyCosts / 100);
                overallOtherCost += otherDailyConnection / 100;

                loader.classList.add('hidden');
                messageSection.classList.add('hidden');
                resultsSection.classList.remove('hidden');
                displayResults(cachedChannelData, overallAmberCost, overallOtherCost, startDateValue, endDateValue, numDays, demandTariffInfo, otherDemandTariffInfo);

            } catch (error) {
                console.error('Error:', error);
                cachedChannelData = null;
                loader.classList.add('hidden');
                messageSection.classList.remove('hidden');
                messageEl.textContent = `Error: ${error.message}`;
            }
        });

        // --- Helper Functions ---
        
        /**
         * Generates and downloads a CSV of all channels' usage (nemTime, channelIdentifier, kWh, perKwh).
         */
        function generateAndDownloadCSV() {
            if (!cachedChannelData) {
                // Custom modal or message box instead of alert()
                const messageBox = document.createElement('div');
                messageBox.innerHTML = `
                    <div class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full" id="my-modal">
                        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                            <div class="mt-3 text-center">
                                <h3 class="text-lg leading-6 font-medium text-gray-900">No Data Available</h3>
                                <div class="mt-2 px-7 py-3">
                                    <p class="text-sm text-gray-500">No data available to export. Please fetch data first.</p>
                                </div>
                                <div class="items-center px-4 py-3">
                                    <button id="close-modal" class="px-4 py-2 bg-indigo-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                                        OK
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(messageBox);
                document.getElementById('close-modal').addEventListener('click', () => {
                    messageBox.remove();
                });
                return;
            }

            let csvContent = "nemTime,channelIdentifier,kWh,SpotPrice_cents_per_kWh\n";
            
            Object.values(cachedChannelData).forEach(channel => {
                if (!channel.usageData || channel.usageData.length === 0) return;
                channel.usageData.forEach(item => {
                    const nemTime = item.nemTime || '';
                    const kwh = (item.kwh !== undefined && item.kwh !== null) ? item.kwh : '';
                    const perKwh = (item.perKwh !== undefined && item.perKwh !== null) ? item.perKwh : '';
                    const row = `"${nemTime}",${channel.identifier},${kwh},${perKwh}\n`;
                    csvContent += row;
                });
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            link.setAttribute("download", `amber_usage_all_channels_${startDate}_to_${endDate}.csv`);
            
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * Determines the TOU rate for a given timestamp based on a standard structure.
         */
        function getTouRate(date, rates) {
            const day = date.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
            const hour = date.getHours();
            const isWeekday = day >= 1 && day <= 5;

            if (hour >= 22 || hour < 7) {
                return rates.offpeak;
            }
            if (isWeekday) {
                if (hour >= 14 && hour < 20) {
                    return rates.peak;
                }
                return rates.shoulder;
            } else {
                return rates.shoulder;
            }
        }
        
        /**
         * Calculates the 'Other Supplier' cost for each channel based on the selected rate type.
         */
        function calculateOtherSupplierCosts(channelTotals, otherDemandCost) {
            const rateType = document.querySelector('input[name="rateType"]:checked').value;

            if (rateType === 'flat') {
                const otherSupplierRate = parseFloat(document.getElementById('otherSupplierRate').value) || 0;
                const feedInRate = parseFloat(document.getElementById('otherSupplierFeedInRateFlat').value) || 0;
                
                Object.values(channelTotals).forEach(c => {
                    if (c.type === 'feedIn') {
                        c.totalOtherCost = -1 * (c.totalKWh * feedInRate) / 100;
                    } else if (c.type === 'general') {
                        // Add demand cost to the general channel
                        c.totalOtherCost = (c.totalKWh * otherSupplierRate) / 100 + otherDemandCost;
                    } else {
                         c.totalOtherCost = (c.totalKWh * otherSupplierRate) / 100;
                    }
                });
            } else { // 'tou'
                const touRates = {
                    peak: parseFloat(document.getElementById('tou_peak_rate').value) || 0,
                    shoulder: parseFloat(document.getElementById('tou_shoulder_rate').value) || 0,
                    offpeak: parseFloat(document.getElementById('tou_offpeak_rate').value) || 0
                };
                 const feedInRate = parseFloat(document.getElementById('otherSupplierFeedInRateTou').value) || 0;
                 const controlledLoadRate = parseFloat(document.getElementById('tou_controlled_load_rate').value) || 0;

                Object.values(channelTotals).forEach(c => {
                    let channelOtherCost = 0;
                    if (c.type === 'feedIn') {
                        channelOtherCost = -1 * (c.totalKWh * feedInRate) / 100;
                    } else if (c.type === 'controlledLoad') {
                        channelOtherCost = (c.totalKWh * controlledLoadRate) / 100;
                    }
                    else if (c.type === 'general') { 
                        channelOtherCost = c.usageData.reduce((total, item) => {
                            const itemDate = new Date(item.nemTime);
                            const rateForInterval = getTouRate(itemDate, touRates);
                            return total + ((parseFloat(item.kwh) || 0) * rateForInterval / 100);
                        }, 0);
                        // Add demand cost to general channel
                        channelOtherCost += otherDemandCost;
                    }
                    c.totalOtherCost = channelOtherCost;
                });
            }
        }
        
        /**
         * Calculates Amber's Demand Tariff based on peak usage in demand windows from API.
         */
        function calculateDemandTariff(channelTotals) {
            const generalChannel = Object.values(cachedChannelData).find(c => c.type === 'general');

            if (!generalChannel || !generalChannel.usageData || generalChannel.usageData.length === 0) {
                return { cost: 0, maxDemandKwh: 0, demandDays: 0, maxDemandTime: null };
            }

            const demandWindowUsage = generalChannel.usageData.filter(item =>
                item.tariffInformation && item.tariffInformation.demandWindow === true
            );

            if (demandWindowUsage.length === 0) {
                return { cost: 0, maxDemandKwh: 0, demandDays: 0, maxDemandTime: null };
            }

            // Group 5-min intervals into 30-min chunks and sum their kWh
            const thirtyMinChunks = {};
            demandWindowUsage.forEach(item => {
                const itemDate = new Date(item.nemTime);
                const minutes = itemDate.getMinutes();
                itemDate.setSeconds(0, 0);

                if (minutes < 30) {
                    itemDate.setMinutes(0);
                } else {
                    itemDate.setMinutes(30);
                }
                const blockStartTime = itemDate.toISOString();

                if (!thirtyMinChunks[blockStartTime]) {
                    thirtyMinChunks[blockStartTime] = 0;
                }
                thirtyMinChunks[blockStartTime] += (parseFloat(item.kwh) || 0);
            });

            // Find the 30-min chunk with the highest usage
            let maxDemandKwh = 0;
            let maxDemandTime = null;

            for (const startTime in thirtyMinChunks) {
                if (thirtyMinChunks[startTime] > maxDemandKwh) {
                    maxDemandKwh = thirtyMinChunks[startTime];
                    maxDemandTime = startTime;
                }
            }
            
            if (maxDemandKwh === 0) {
                 return { cost: 0, maxDemandKwh: 0, demandDays: 0, maxDemandTime: null };
            }

            // Find the unique days that had a demand window
            const demandDaysSet = new Set(
                demandWindowUsage.map(item => item.nemTime.substring(0, 10))
            );
            const numberOfDemandDays = demandDaysSet.size;

            // Calculate the final cost
            const demandTariffCost = maxDemandKwh * 2 * (AMBER_DEMAND_TARIFF_COST_PER_KW_CENTS / 100) * numberOfDemandDays;

            return {
                cost: demandTariffCost,
                maxDemandKwh: maxDemandKwh,
                demandDays: numberOfDemandDays,
                maxDemandTime: maxDemandTime
            };
        }
        
        /**
         * NEW: Calculates the Demand Tariff for the other supplier based on form inputs.
         */
        function calculateOtherDemandTariff(channelTotals, numDays) {
            const isEnabled = document.getElementById('enableDemandTariff').checked;
            if (!isEnabled) {
                return { cost: 0, maxDemandKwh: 0, maxDemandTime: null };
            }

            const generalChannel = Object.values(channelTotals).find(c => c.type === 'general');
            if (!generalChannel || !generalChannel.usageData || !generalChannel.usageData.length === 0) {
                return { cost: 0, maxDemandKwh: 0, maxDemandTime: null };
            }
            
            const demandRate = parseFloat(document.getElementById('demandRate').value) || 0;
            const startTime = document.getElementById('demandWindowStart').value;
            const endTime = document.getElementById('demandWindowEnd').value;

            const [startHour, startMin] = startTime.split(':').map(Number);
            const [endHour, endMin] = endTime.split(':').map(Number);

            // Filter for weekdays within the demand window
            const demandWindowUsage = generalChannel.usageData.filter(item => {
                const d = new Date(item.nemTime);
                const day = d.getDay(); // 0=Sun, 6=Sat
                if (day === 0 || day === 6) return false;

                const hour = d.getHours();
                const min = d.getMinutes();
                
                const timeInMins = hour * 60 + min;
                const startInMins = startHour * 60 + startMin;
                const endInMins = endHour * 60 + endMin;

                return timeInMins >= startInMins && timeInMins < endInMins;
            });
            
            if (demandWindowUsage.length === 0) {
                return { cost: 0, maxDemandKwh: 0, maxDemandTime: null };
            }

            // Group into 30-min chunks
            const thirtyMinChunks = {};
            demandWindowUsage.forEach(item => {
                const itemDate = new Date(item.nemTime);
                const minutes = itemDate.getMinutes();
                itemDate.setSeconds(0, 0);

                if (minutes < 30) {
                    itemDate.setMinutes(0);
                } else {
                    itemDate.setMinutes(30);
                }
                const blockStartTime = itemDate.toISOString();

                if (!thirtyMinChunks[blockStartTime]) {
                    thirtyMinChunks[blockStartTime] = 0;
                }
                thirtyMinChunks[blockStartTime] += (parseFloat(item.kwh) || 0);
            });
            
            // Find the highest 30-min usage across the whole period
            let maxDemandKwh = 0;
            let maxDemandTime = null;
            for (const startTime in thirtyMinChunks) {
                if (thirtyMinChunks[startTime] > maxDemandKwh) {
                    maxDemandKwh = thirtyMinChunks[startTime];
                    maxDemandTime = startTime;
                }
            }
            
            if (maxDemandKwh === 0) {
                return { cost: 0, maxDemandKwh: 0, maxDemandTime: null };
            }
            
            // Cost = (Max kWh in 30min * 2 to get kW) * (Rate in c/kW/day) * (Number of Days) / 100 (to get $)
            const demandCost = (maxDemandKwh * 2) * (demandRate / 100) * numDays;
            
            return {
                cost: demandCost,
                maxDemandKwh: maxDemandKwh,
                maxDemandTime: maxDemandTime
            };
        }


        /**
         * Renders an interactive chart of average 24hr usage and pricing.
         */
        function displayAverageGraph() {
            const averageGraphContainer = document.getElementById('averageGraphContainer');
            
            if (!cachedChannelData) {
                console.error("No data available for graph.");
                averageGraphContainer.innerHTML = '<p class="text-center text-red-500">No data available to render graph.</p>';
                return;
            }
            const generalChannel = Object.values(cachedChannelData).find(c => c.type === 'general');
            const feedInChannel = Object.values(cachedChannelData).find(c => c.type === 'feedIn');
            const controlledLoadChannel = Object.values(cachedChannelData).find(c => c.type === 'controlledLoad');

            if (!generalChannel || !generalChannel.usageData || generalChannel.usageData.length === 0) {
                console.error("No general usage data for graph.");
                 averageGraphContainer.innerHTML = '<p class="text-center text-red-500">No general usage data found to render graph.</p>';
                return;
            }

            const intervals = Array.from({ length: 48 }, () => ({ totalKwh: 0, totalCents: 0, count: 0 }));
            
            const startDate = new Date(document.getElementById('startDate').value + 'T00:00:00');
            const endDate = new Date(document.getElementById('endDate').value + 'T00:00:00');
            const numDays = Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;

            generalChannel.usageData.forEach(item => {
                const nemTimeStr = item.nemTime;
                const hours = parseInt(nemTimeStr.substring(11, 13));
                const minutes = parseInt(nemTimeStr.substring(14, 16));
                const intervalIndex = hours * 2 + Math.floor(minutes / 30);
                
                if (intervals[intervalIndex]) {
                    intervals[intervalIndex].totalKwh += (parseFloat(item.kwh) || 0);
                    intervals[intervalIndex].totalCents += (parseFloat(item.perKwh) || 0);
                    intervals[intervalIndex].count += 1;
                }
            });

            const feedInIntervals = Array.from({ length: 48 }, () => ({ totalKwh: 0 }));
            if (feedInChannel && feedInChannel.usageData) {
                feedInChannel.usageData.forEach(item => {
                    const nemTimeStr = item.nemTime;
                    const hours = parseInt(nemTimeStr.substring(11, 13));
                    const minutes = parseInt(nemTimeStr.substring(14, 16));
                    const intervalIndex = hours * 2 + Math.floor(minutes / 30);
                    
                    if (feedInIntervals[intervalIndex]) {
                        feedInIntervals[intervalIndex].totalKwh += (parseFloat(item.kwh) || 0);
                    }
                });
            }
            
            const controlledLoadIntervals = Array.from({ length: 48 }, () => ({ totalKwh: 0 }));
            if (controlledLoadChannel && controlledLoadChannel.usageData) {
                controlledLoadChannel.usageData.forEach(item => {
                    const nemTimeStr = item.nemTime;
                    const hours = parseInt(nemTimeStr.substring(11, 13));
                    const minutes = parseInt(nemTimeStr.substring(14, 16));
                    const intervalIndex = hours * 2 + Math.floor(minutes / 30);

                    if (controlledLoadIntervals[intervalIndex]) {
                        controlledLoadIntervals[intervalIndex].totalKwh += (parseFloat(item.kwh) || 0);
                    }
                });
            }

            const labels = [];
            for (let i = 0; i < 48; i++) {
                const hour = Math.floor(i / 2);
                const minute = (i % 2 === 0) ? '00' : '30';
                labels.push(`${hour.toString().padStart(2, '0')}:${minute}`);
            }
            
            const avgUsageData = intervals.map(i => numDays > 0 ? (i.totalKwh / numDays) * 2 : 0);
            const avgFeedInData = feedInIntervals.map(i => numDays > 0 ? (-i.totalKwh / numDays) * 2 : 0); // Made negative and scaled
            const avgControlledLoadData = controlledLoadIntervals.map(i => numDays > 0 ? (i.totalKwh / numDays) * 2 : 0);
            const avgPriceData = intervals.map(i => i.count > 0 ? (i.totalCents / i.count) : 0);

            const ctx = document.getElementById('usagePriceChart').getContext('2d');
            
            if (usageChart) {
                usageChart.destroy();
            }
            
            // --- ONLY show controlled load dataset when channel exists AND has non-zero totalKWh ---
            const chartDatasets = [];
            
            const avgDailyGeneralKwh = (generalChannel?.totalKWh || 0) / numDays;
            const avgDailyFeedInKwh = (feedInChannel?.totalKWh || 0) / numDays;
            const avgDailyControlledLoadKwh = (controlledLoadChannel?.totalKWh || 0) / numDays;

            // NEW: Calculate average price based on total cost / total usage
            const generalAvgPrice = (generalChannel?.totalKWh > 0 ? ((generalChannel.totalAmberCost * 100) / generalChannel.totalKWh) : 0).toFixed(2);
            const feedInAvgPrice = (feedInChannel?.totalKWh > 0 ? ((-feedInChannel.totalAmberCost * 100) / feedInChannel.totalKWh) : 0).toFixed(2);
            const controlledLoadAvgPrice = (controlledLoadChannel?.totalKWh > 0 ? ((controlledLoadChannel.totalAmberCost * 100) / controlledLoadChannel.totalKWh) : 0).toFixed(2);


            if (controlledLoadChannel && (controlledLoadChannel.totalKWh || 0) > 0) {
                chartDatasets.push({
                    label: `Average Controlled Load (kW) - Total: ${avgDailyControlledLoadKwh.toFixed(2)} kWh, Price: ${controlledLoadAvgPrice} c/kWh`,
                    data: avgControlledLoadData,
                    backgroundColor: 'rgba(13, 110, 253, 0.6)',
                    borderColor: 'rgba(13, 110, 253, 1)',
                    yAxisID: 'yUsage',
                    order: 2,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                });
            }

            chartDatasets.push({
                label: `Average Usage (kW) - Total: ${avgDailyGeneralKwh.toFixed(2)} kWh, Price: ${generalAvgPrice} c/kWh`,
                data: avgUsageData,
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                borderColor: 'rgba(54, 162, 235, 1)',
                yAxisID: 'yUsage',
                order: 2,
                barPercentage: 1.0,
                categoryPercentage: 1.0
            });

            if (feedInChannel) {
                chartDatasets.push({
                    label: `Average Feed-in (kW) - Total: ${avgDailyFeedInKwh.toFixed(2)} kWh, Price: ${feedInAvgPrice} c/kWh`,
                    data: avgFeedInData,
                    backgroundColor: 'rgba(40, 167, 69, 0.6)',
                    borderColor: 'rgba(40, 167, 69, 1)',
                    yAxisID: 'yUsage',
                    order: 2,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                });
            }

            chartDatasets.push({
                label: 'Average Spot Price (c/kWh)',
                data: avgPriceData,
                type: 'line',
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                fill: false,
                yAxisID: 'yPrice',
                order: 1
            });

            const allUsage = [...avgUsageData, ...avgFeedInData, ...avgControlledLoadData];
            const usageMin = Math.min(...allUsage);
            const usageMax = Math.max(...allUsage);
            const priceMax = Math.max(...avgPriceData.filter(p => p !== null));

            let priceAxisOptions = {
                type: 'linear',
                display: true,
                position: 'right',
                title: { display: true, text: 'Average Spot Price (c/kWh)' },
                grid: { drawOnChartArea: false },
            };

            if (usageMin < 0 && usageMax > 0 && priceMax > 0) {
                const ratio = -usageMin / (usageMax - usageMin);
                const newPriceMin = (ratio * priceMax) / (ratio - 1);
                priceAxisOptions.min = Math.floor(newPriceMin / 5) * 5;
                priceAxisOptions.max = Math.ceil(priceMax / 5) * 5;
            }

            usageChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: chartDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                callback: function(value, index, ticks) {
                                    const label = this.getLabelForValue(value);
                                    if (index % 4 === 0) return label; // Every 2 hours
                                    if (index === ticks.length - 1) return '24:00';
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: function(context) {
                                    if (context.index % 2 === 0) { // Darker for hourly
                                        return 'rgba(0, 0, 0, 0.2)';
                                    }
                                    return 'rgba(0, 0, 0, 0.05)'; // Lighter for 30-min
                                },
                            }
                        },
                        yUsage: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Average Power (kW)' },
                            stacked: true
                        },
                        yPrice: priceAxisOptions
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Average 24-Hour Usage vs. Spot Price (${document.getElementById('startDate').value} to ${document.getElementById('endDate').value})`
                        },
                        tooltip: {
                            position: 'cursor',
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'yPrice') {
                                            label = `Price: ${parseFloat(context.parsed.y).toFixed(2)} c/kWh`;
                                        } else {
                                            label = `Usage: ${parseFloat(context.parsed.y).toFixed(2)} kW`;
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        /**
         * Renders an interactive chart of usage and pricing for a single selected day.
         */
        function displayDailyGraph(selectedDateStr) {
            if (!cachedChannelData) return;

            const generalChannel = Object.values(cachedChannelData).find(c => c.type === 'general');
            const feedInChannel = Object.values(cachedChannelData).find(c => c.type === 'feedIn');
            const controlledLoadChannel = Object.values(cachedChannelData).find(c => c.type === 'controlledLoad');

            if (!generalChannel || !generalChannel.usageData || generalChannel.usageData.length === 0) {
                console.error("No general usage data for daily graph.");
                return;
            }

            const dayData = generalChannel.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr);
            
            const intervals = Array.from({ length: 288 }, () => ({ kwh: 0, price: null, count: 0 }));

            dayData.forEach(item => {
                const nemTimeStr = item.nemTime;
                const hours = parseInt(nemTimeStr.substring(11, 13));
                const minutes = parseInt(nemTimeStr.substring(14, 16));
                const intervalIndex = hours * 12 + Math.floor(minutes / 5);
                
                if(intervals[intervalIndex]) {
                    intervals[intervalIndex].kwh += (parseFloat(item.kwh) || 0);
                    intervals[intervalIndex].price = (intervals[intervalIndex].price || 0) + (parseFloat(item.perKwh) || 0);
                    intervals[intervalIndex].count += 1;
                }
            });

            const feedInIntervals = Array.from({ length: 288 }, () => ({ kwh: 0 }));
            if (feedInChannel && feedInChannel.usageData) {
                const dayDataFeedIn = feedInChannel.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr);
                dayDataFeedIn.forEach(item => {
                    const nemTimeStr = item.nemTime;
                    const hours = parseInt(nemTimeStr.substring(11, 13));
                    const minutes = parseInt(nemTimeStr.substring(14, 16));
                    const intervalIndex = hours * 12 + Math.floor(minutes / 5);

                    if (feedInIntervals[intervalIndex]) {
                        feedInIntervals[intervalIndex].kwh += (parseFloat(item.kwh) || 0);
                    }
                });
            }
            
            const controlledLoadIntervals = Array.from({ length: 288 }, () => ({ kwh: 0 }));
            if (controlledLoadChannel && controlledLoadChannel.usageData) {
                const dayDataControlled = controlledLoadChannel.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr) || [];
                dayDataControlled.forEach(item => {
                    const nemTimeStr = item.nemTime;
                    const hours = parseInt(nemTimeStr.substring(11, 13));
                    const minutes = parseInt(nemTimeStr.substring(14, 16));
                    const intervalIndex = hours * 12 + Math.floor(minutes / 5);

                    if (controlledLoadIntervals[intervalIndex]) {
                        controlledLoadIntervals[intervalIndex].kwh += (parseFloat(item.kwh) || 0);
                    }
                });
            }

            const labels = intervals.map((_, i) => {
                const hour = Math.floor(i / 12).toString().padStart(2, '0');
                const minute = ((i % 12) * 5).toString().padStart(2, '0');
                return `${hour}:${minute}`;
            });

            const usageData = intervals.map(i => i.kwh * 12);
            const feedInData = feedInIntervals.map(i => -i.kwh * 12); // Made negative and scaled
            const controlledLoadData = controlledLoadIntervals.map(i => i.kwh * 12);
            const priceData = intervals.map(i => i.count > 0 ? i.price / i.count : null);

            const ctx = document.getElementById('dailyChart').getContext('2d');
            if (dailyUsageChart) {
                dailyUsageChart.destroy();
            }
            
            // --- ONLY include controlled load dataset when channel exists AND has non-zero totalKWh ---
            const chartDatasets = [];

            // Calculate daily totals for accurate average price
            const dailyGeneralKwh = dayData.reduce((total, item) => total + (parseFloat(item.kwh) || 0), 0);
            const dailyGeneralCost = dayData.reduce((total, item) => total + ((parseFloat(item.perKwh) || 0) / 100) * (parseFloat(item.kwh) || 0), 0);
            const dailyGeneralAvgPrice = (dailyGeneralKwh > 0 ? (dailyGeneralCost / dailyGeneralKwh) * 100 : 0).toFixed(2);
            
            const dayDataFeedIn = feedInChannel?.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr) || [];
            const dailyFeedInKwh = dayDataFeedIn.reduce((total, item) => total + (parseFloat(item.kwh) || 0), 0);
            const dailyFeedInCost = dayDataFeedIn.reduce((total, item) => total + ((parseFloat(item.perKwh) || 0) / 100) * (parseFloat(item.kwh) || 0), 0);
            const dailyFeedInAvgPrice = (dailyFeedInKwh > 0 ? ((-dailyFeedInCost) / dailyFeedInKwh) * 100 : 0).toFixed(2);

            const dayDataControlled = controlledLoadChannel?.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr) || [];
            const dailyControlledLoadKwh = dayDataControlled.reduce((total, item) => total + (parseFloat(item.kwh) || 0), 0);
            const dailyControlledLoadCost = dayDataControlled.reduce((total, item) => total + ((parseFloat(item.perKwh) || 0) / 100) * (parseFloat(item.kwh) || 0), 0);
            const dailyControlledLoadAvgPrice = (dailyControlledLoadKwh > 0 ? (dailyControlledLoadCost / dailyControlledLoadKwh) * 100 : 0).toFixed(2);


            if (controlledLoadChannel && (controlledLoadChannel.totalKWh || 0) > 0) {
                 chartDatasets.push({
                    label: `Controlled Load (kW) - Total: ${dailyControlledLoadKwh.toFixed(2)} kWh, Avg Price: ${dailyControlledLoadAvgPrice} c/kWh`,
                    data: controlledLoadData,
                    backgroundColor: 'rgba(13, 110, 253, 0.6)',
                    borderColor: 'rgba(13, 110, 253, 1)',
                    yAxisID: 'yUsage',
                    order: 2,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                });
            }

            chartDatasets.push({
                label: `Usage (kW) - Total: ${dailyGeneralKwh.toFixed(2)} kWh, Avg Price: ${dailyGeneralAvgPrice} c/kWh`,
                data: usageData,
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                borderColor: 'rgba(54, 162, 235, 1)',
                yAxisID: 'yUsage',
                order: 2,
                barPercentage: 1.0,
                categoryPercentage: 1.0
            });

            if (feedInChannel) {
                chartDatasets.push({
                    label: `Feed-in (kW) - Total: ${dailyFeedInKwh.toFixed(2)} kWh, Avg Price: ${dailyFeedInAvgPrice} c/kWh`,
                    data: feedInData,
                    backgroundColor: 'rgba(40, 167, 69, 0.6)',
                    borderColor: 'rgba(40, 167, 69, 1)',
                    yAxisID: 'yUsage',
                    order: 2,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                });
            }
            
            chartDatasets.push({
                label: 'Spot Price (c/kWh)',
                data: priceData,
                type: 'line',
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                pointRadius: 0,
                borderWidth: 2,
                fill: false,
                yAxisID: 'yPrice',
                order: 1,
                spanGaps: true,
            });
            
            const allUsage = [...usageData, ...feedInData, ...controlledLoadData];
            const usageMin = Math.min(...allUsage);
            const usageMax = Math.max(...allUsage);
            const priceMax = Math.max(...priceData.filter(p => p !== null));

            let priceAxisOptions = {
                type: 'linear',
                display: true,
                position: 'right',
                title: { display: true, text: 'Spot Price (c/kWh)' },
                grid: { drawOnChartArea: false },
            };

            if (usageMin < 0 && usageMax > 0 && priceMax > 0) {
                const ratio = -usageMin / (usageMax - usageMin);
                const newPriceMin = (ratio * priceMax) / (ratio - 1);
                priceAxisOptions.min = Math.floor(newPriceMin / 5) * 5;
                priceAxisOptions.max = Math.ceil(priceMax / 5) * 5;
            }

            dailyUsageChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: chartDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { 
                            stacked: true,
                            ticks: { 
                                callback: function(value, index, ticks) {
                                    const label = this.getLabelForValue(value);
                                    if (index % 24 === 0) return label; // Every 2 hours
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: function(context) {
                                    if (context.index % 12 === 0) { // Darker for hourly
                                        return 'rgba(0, 0, 0, 0.2)';
                                    }
                                     if (context.index % 6 === 0) { // Lighter for 30-min
                                        return 'rgba(0, 0, 0, 0.05)';
                                    }
                                    return 'transparent';
                                },
                            }
                        },
                        yUsage: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Power (kW)' },
                            stacked: true,
                        },
                        yPrice: priceAxisOptions
                    },
                    plugins: {
                        title: { display: true, text: `Usage vs. Spot Price for ${selectedDateStr}` },
                        tooltip: {
                            position: 'cursor',
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'yPrice') {
                                            label = `Price: ${parseFloat(context.parsed.y).toFixed(2)} c/kWh`;
                                        } else {
                                            label = `Usage: ${parseFloat(context.parsed.y).toFixed(2)} kW`;
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        /**
         * Renders the final results table and summary.
         */
        function displayResults(channelTotals, overallAmberCost, overallOtherCost, startDateStr, endDateStr, numDays, demandTariffInfo, otherDemandTariffInfo) {
            const resultsTableContainer = document.getElementById('results-table-container');
            const downloadCsvButton = document.getElementById('downloadCsvButton');
            const averageGraphContainer = document.getElementById('averageGraphContainer');
            const dailyGraphSection = document.getElementById('dailyGraphSection');

            const planName = document.getElementById('planName').value.trim() || 'Other Supplier';
            const period = `(${startDateStr} to ${endDateStr})`;
            const otherDailyConnection = (parseFloat(document.getElementById('dailyConnectionRate').value) || 0) * numDays;
            
            let tableHTML = `
                <p class="text-sm text-gray-500 mb-4">Period: ${numDays} days ${period}</p>
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Channel</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Usage (kWh)</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amber</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${planName}</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
            `;

            Object.values(channelTotals).forEach(c => {
                if (c.totalKWh === 0 && c.totalAmberCost === 0 && c.totalOtherCost === 0) {
                    return; // Skip this line if all values are zero
                }
                const totalKWhText = (c.totalKWh || 0).toFixed(2);
                const totalAmberCostText = (c.totalAmberCost || 0).toFixed(2);
                const totalOtherCostText = (c.totalOtherCost || 0).toFixed(2);
                tableHTML += `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${c.identifier}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${c.type}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${totalKWhText}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$${totalAmberCostText}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$${totalOtherCostText}</td>
                    </tr>
                `;
            });
            
            if (demandTariffInfo && demandTariffInfo.cost > 0) {
                const maxDemandKw = ((demandTariffInfo.maxDemandKwh || 0) * 2).toFixed(2);
                const maxDemandDateTime = new Date(demandTariffInfo.maxDemandTime).toLocaleString('en-AU', { dateStyle: 'short', timeStyle: 'short' });
                
                tableHTML += `
                    <tr class="font-semibold border-t">
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" colspan="2">Amber Demand Tariff</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            <div class="text-xs">Max: ${maxDemandKw} kW</div>
                            <div class="text-xs text-blue-600 font-normal">on ${maxDemandDateTime}</div>                            
                            <div class="text-xs">X ${demandTariffInfo.demandDays} days</div>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">$${(demandTariffInfo.cost || 0).toFixed(2)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500"></td>
                    </tr>
                `;
            }
            
             if (otherDemandTariffInfo && otherDemandTariffInfo.cost > 0) {
                const maxDemandKw = ((otherDemandTariffInfo.maxDemandKwh || 0) * 2).toFixed(2);
                const maxDemandDateTime = new Date(otherDemandTariffInfo.maxDemandTime).toLocaleString('en-AU', { dateStyle: 'short', timeStyle: 'short' });
                
                tableHTML += `
                    <tr class="font-semibold border-t">
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" colspan="2">${planName} Demand Tariff</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            <div class="text-xs">Max: ${maxDemandKw} kW</div>
                            <div class="text-xs text-blue-600 font-normal">on ${maxDemandDateTime}</div>                            
                            <div class="text-xs">X ${numDays} days</div>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900"></td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 italic">$${(otherDemandTariffInfo.cost || 0).toFixed(2)}</td>
                    </tr>
                `;
            }


            tableHTML += `
                <tr class="font-semibold border-t">
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900" colspan="3">Daily Connection</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">$${(AMBER_CONNECTION_COST_PER_DAY_CENTS * numDays / 100).toFixed(2)}</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">$${(otherDailyConnection / 100).toFixed(2)}</td>
                </tr>
                <tr class="font-semibold">
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900" colspan="3">Amber Subscription</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">$${(AMBER_SUBSCRIPTION_COST_PER_DAY_CENTS * numDays / 100).toFixed(2)}</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">N/A</td>
                </tr>
            `;

             tableHTML += `
                    <tr class="bg-gray-50 font-bold">
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" colspan="3">Total</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">$${(overallAmberCost || 0).toFixed(2)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">$${(overallOtherCost || 0).toFixed(2)}</td>
                    </tr>
                </tbody>
                </table>
            `;
            
            const savings = (overallOtherCost || 0) - (overallAmberCost || 0);
            let savingsSummaryHTML = '<div class="mt-6 p-4 rounded-lg text-center ';
            if (savings > 0) {
                savingsSummaryHTML += 'bg-green-100">';
                savingsSummaryHTML += `<p class="text-lg font-medium text-green-800">You saved <span class="font-bold">$${savings.toFixed(2)}</span> with Amber compared to ${planName}!</p>`;
            } else {
                 savingsSummaryHTML += 'bg-red-100">';
                 savingsSummaryHTML += `<p class="text-lg font-medium text-red-800">It would have been <span class="font-bold">$${Math.abs(savings).toFixed(2)}</span> cheaper with ${planName}.</p>`;
            }
            savingsSummaryHTML += '</div>';

            resultsTableContainer.innerHTML = tableHTML + savingsSummaryHTML;
            
            downloadCsvButton.disabled = false;

            // Make graphs visible and render them
            averageGraphContainer.classList.remove('hidden');
            dailyGraphSection.classList.remove('hidden');
            displayAverageGraph(); // Call the average graph renderer

            const daySelector = document.getElementById('daySelector');
            const prevDayBtn = document.getElementById('prevDayBtn');
            const nextDayBtn = document.getElementById('nextDayBtn');
            
            daySelector.innerHTML = ''; 

            const start = new Date(startDateStr + 'T00:00:00');
            const end = new Date(endDateStr + 'T00:00:00');
            let current = new Date(start);

            while (current <= end) {
                const dateValue = formatForInput(current);
                const option = document.createElement('option');
                option.value = dateValue;
                option.textContent = dateValue;
                daySelector.appendChild(option);
                current.setDate(current.getDate() + 1);
            }

            daySelector.onchange = () => {
                displayDailyGraph(daySelector.value);
                updateNavButtons();
            };

            prevDayBtn.onclick = () => {
                if (daySelector.selectedIndex > 0) {
                    daySelector.selectedIndex--;
                    daySelector.dispatchEvent(new Event('change'));
                }
            };

            nextDayBtn.onclick = () => {
                 if (daySelector.selectedIndex < daySelector.options.length - 1) {
                    daySelector.selectedIndex++;
                    daySelector.dispatchEvent(new Event('change'));
                }
            };
            
            function updateNavButtons() {
                prevDayBtn.disabled = daySelector.selectedIndex === 0;
                nextDayBtn.disabled = daySelector.selectedIndex === daySelector.options.length - 1;
            }

            if (daySelector.options.length > 0) {
                 daySelector.dispatchEvent(new Event('change'));
            }
        }

    </script>
</body>
</html>

