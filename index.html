<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amber Electric Cost Comparator & Exporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-4xl">
        <header class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-900">Amber Electric Cost Comparator & Exporter</h1>
            <p class="mt-2 text-gray-600">Enter your Amber API key and select a date range to compare costs or export your usage data.</p>
        </header>

        <main>
            <div id="apiKeySection" class="bg-white rounded-lg shadow-md p-6 mb-6">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="md:col-span-2">
                        <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-1">Amber API Key</label>
                        <input type="password" id="apiKey" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="psk_...">
                        <p class="text-xs text-gray-500 mt-1">Your key is stored only in your browser. Find it at <a href="https://app.amber.com.au/developers" target="_blank" class="text-indigo-600 hover:underline">app.amber.com.au/developers</a>.</p>
                    </div>

                    <!-- Modified Other Supplier Details Section -->
                    <div class="md:col-span-2 border-t pt-4">
                         <div class="flex justify-between items-center mb-2">
                            <label class="block text-base font-medium text-gray-800">Other Supplier Details</label>
                            <button id="toggleSupplierDetailsBtn" class="text-sm text-indigo-600 hover:text-indigo-800 font-semibold focus:outline-none rounded px-2 py-1">
                                Show
                            </button>
                        </div>
                        <div id="otherSupplierDetailsContainer" class="hidden transition-all duration-300">
                             <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Rate Structure</label>
                                <div class="flex items-center space-x-4" id="rateTypeSelector">
                                    <label class="flex items-center">
                                        <input type="radio" name="rateType" value="flat" class="focus:ring-indigo-500 h-4 w-4 text-indigo-600 border-gray-300" checked>
                                        <span class="ml-2 text-sm text-gray-700">Flat Rate</span>
                                    </label>
                                    <label class="flex items-center">
                                        <input type="radio" name="rateType" value="tou" class="focus:ring-indigo-500 h-4 w-4 text-indigo-600 border-gray-300">
                                        <span class="ml-2 text-sm text-gray-700">Time of Use (TOU)</span>
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Daily Connection input for Flat and TOU -->
                            <div class="mb-4">
                                <label for="dailyConnectionRate" class="block text-sm font-medium text-gray-700 mb-1">Daily Connection (c/day)</label>
                                <input type="number" id="dailyConnectionRate" value="102.83" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                <p class="text-xs text-gray-500 mt-1">This is a fixed daily service fee.</p>
                            </div>

                            <div id="flatRateSection" class="grid grid-cols-1 sm:grid-cols-2 gap-6">
                                 <div>
                                    <label for="otherSupplierRate" class="block text-sm font-medium text-gray-700 mb-1">General Rate (c/kWh)</label>
                                    <input type="number" id="otherSupplierRate" value="36" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 36">
                                 </div>
                                 <div>
                                    <label for="otherSupplierFeedInRateFlat" class="block text-sm font-medium text-gray-700 mb-1">Feed-in Rate (c/kWh)</label>
                                    <input type="number" id="otherSupplierFeedInRateFlat" value="5" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 5">
                                </div>
                            </div>

                            <div id="touRateSection" class="hidden">
                                <h3 class="text-md font-medium text-gray-800 mt-4 pt-4 border-t border-gray-200 mb-2">Consumption Rates (c/kWh)</h3>
                                <p class="text-xs text-gray-500 mb-3">Rates are based on a standard TOU structure. Weekdays are Mon-Fri.</p>
                                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
                                    <div class="bg-red-50 p-3 rounded-lg border border-red-200">
                                        <label for="tou_peak_rate" class="block text-sm font-medium text-red-700">Peak Rate</label>
                                        <p class="text-xs text-gray-500">2pm - 8pm weekdays</p>
                                        <input type="number" id="tou_peak_rate" value="57.93" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div class="bg-yellow-50 p-3 rounded-lg border border-yellow-200">
                                        <label for="tou_shoulder_rate" class="block text-sm font-medium text-yellow-700">Shoulder Rate</label>
                                        <p class="text-xs text-gray-500">7am-2pm, 8pm-10pm weekdays; 7am-10pm weekends</p>
                                        <input type="number" id="tou_shoulder_rate" value="30.61" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div class="bg-green-50 p-3 rounded-lg border border-green-200">
                                        <label for="tou_offpeak_rate" class="block text-sm font-medium text-green-700">Off-Peak Rate</label>
                                        <p class="text-xs text-gray-500">10pm - 7am every day</p>
                                        <input type="number" id="tou_offpeak_rate" value="24.28" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                    <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                                        <label for="tou_controlled_load_rate" class="block text-sm font-medium text-blue-700">Controlled Load</label>
                                        <p class="text-xs text-gray-500">e.g., Hot water</p>
                                        <input type="number" id="tou_controlled_load_rate" value="14.6" class="w-full mt-1 px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                </div>
                                 <div>
                                    <label for="otherSupplierFeedInRateTou" class="block text-sm font-medium text-gray-700 mb-1">Feed-in Rate (c/kWh)</label>
                                    <input type="number" id="otherSupplierFeedInRateTou" value="4.0" class="w-full max-w-xs px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 5">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="border-t pt-4">
                        <label for="startDate" class="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                        <input type="date" id="startDate" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                     <div class="border-t pt-4">
                        <label for="endDate" class="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                        <input type="date" id="endDate" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>
                 <div class="mt-6 text-right">
                    <button id="fetchData" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Compare Costs
                    </button>
                </div>
            </div>

            <div id="messageSection" class="hidden text-center p-6 bg-white rounded-lg shadow-md">
                <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12 mx-auto mb-4 hidden"></div>
                <div id="message" class="text-left"></div>
            </div>

            <div id="resultsSection" class="hidden">
                 <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl sm:text-2xl font-bold text-gray-900">Comparison Results</h2>
                    <div class="flex space-x-2">
                        <button id="showGraphButton" disabled class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                            Show 24hr Avg Graph
                        </button>
                        <button id="downloadCsvButton" disabled class="bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                            Download CSV
                        </button>
                    </div>
                 </div>
                 <div id="graphContainer" class="hidden bg-white rounded-lg shadow-md p-6 mb-6 h-[80vh]">
                    <canvas id="usagePriceChart"></canvas>
                </div>
                 <div id="results-output" class="bg-white rounded-lg shadow-md p-6 overflow-x-auto">
                 </div>
                <div id="dailyGraphSection" class="hidden bg-white rounded-lg shadow-md p-6 mt-6">
                    <h3 class="text-xl font-bold text-gray-900 mb-4">Daily Usage & Price Graph</h3>
                    <div class="flex items-center space-x-2 sm:space-x-4 mb-4">
                        <button id="prevDayBtn" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 font-semibold">&lt; Prev</button>
                        <select id="daySelector" class="w-full max-w-xs px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></select>
                        <button id="nextDayBtn" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 font-semibold">Next &gt;</button>
                    </div>
                    <div class="h-[70vh] relative">
                        <canvas id="dailyChart"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Amber Electric Constants ---
        const AMBER_CONNECTION_COST_PER_DAY_CENTS = 109.894;
        const AMBER_SUBSCRIPTION_COST_PER_DAY_CENTS = 72.316;
        const AMBER_DEMAND_TARIFF_COST_PER_KW_CENTS = 42.345;
        const AMBER_API_URL = 'https://api.amber.com.au/v1';

        // --- Global cache for API data and charts ---
        let cachedChannelData = null; // Holds the aggregated data for the current period for recalculation/CSV
        let lastFetchedStartDate = null;
        let lastFetchedEndDate = null;
        let usageChart = null;
        let dailyUsageChart = null;

        // --- IndexedDB Caching ---
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AmberDataCache', 1);

                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('usageData')) {
                        // The store holds daily usage data objects. Key is 'YYYY-MM-DD'.
                        db.createObjectStore('usageData', { keyPath: 'date' });
                    }
                };

                request.onsuccess = event => {
                    db = event.target.result;
                    console.log("Database initialized successfully.");
                    resolve(db);
                };

                request.onerror = event => {
                    console.error("Database error:", event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        function saveDataToCache(dailyData) {
            if (!db) return Promise.reject("DB not initialized");
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['usageData'], 'readwrite');
                const store = transaction.objectStore('usageData');
                
                if (dailyData.length === 0) {
                    resolve();
                    return;
                }
                
                let completed = 0;
                dailyData.forEach(dayObject => {
                    const request = store.put(dayObject); // dayObject is { date: 'YYYY-MM-DD', channels: {...} }
                    request.onsuccess = () => {
                        completed++;
                        if (completed === dailyData.length) {
                            resolve();
                        }
                    };
                    request.onerror = (event) => {
                        console.error('Error saving data for date:', dayObject.date, event.target.error);
                        reject(event.target.error);
                    };
                });

                transaction.oncomplete = () => console.log(`Transaction complete: Saved ${dailyData.length} days to cache.`);
                transaction.onerror = (event) => reject(event.target.error);
            });
        }

        function getDataFromCache(dates) {
            if (!db) return Promise.reject("DB not initialized");
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['usageData'], 'readonly');
                const store = transaction.objectStore('usageData');
                const results = {};
                
                if (dates.length === 0) {
                    resolve({});
                    return;
                }

                let completed = 0;
                dates.forEach(date => {
                    const request = store.get(date);
                    request.onsuccess = (event) => {
                        if (event.target.result) {
                            results[date] = event.target.result.channels;
                        }
                        completed++;
                        if (completed === dates.length) {
                            resolve(results);
                        }
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            });
        }
        
        // --- Date & Formatting Helpers ---
        const formatForInput = (date) => {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        
        function toLocalIsoWithOffset(d) {
            function pad(n) { return String(n).padStart(2, '0'); }
            const year = d.getFullYear();
            const month = pad(d.getMonth() + 1);
            const day = pad(d.getDate());
            const hours = pad(d.getHours());
            const minutes = pad(d.getMinutes());
            const seconds = pad(d.getSeconds());
            const offsetMinutes = -d.getTimezoneOffset();
            const sign = offsetMinutes >= 0 ? '+' : '-';
            const absOffset = Math.abs(offsetMinutes);
            const offsetHours = pad(Math.floor(absOffset / 60));
            const offsetMins = pad(absOffset % 60);
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${offsetHours}:${offsetMins}`;
        }

        // --- Event Listeners and Initial Setup ---
        window.addEventListener('DOMContentLoaded', () => {
            const apiKeyInput = document.getElementById('apiKey');
            const savedApiKey = localStorage.getItem('amberApiKey');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
            }

            Chart.Tooltip.positioners.cursor = (items, eventPosition) => eventPosition;

            const endDateInput = document.getElementById('endDate');
            const startDateInput = document.getElementById('startDate');
            
            const savedStartDate = localStorage.getItem('startDate');
            const savedEndDate = localStorage.getItem('endDate');
            
            if (savedStartDate && savedEndDate) {
                startDateInput.value = savedStartDate;
                endDateInput.value = savedEndDate;
            } else {
                const now = new Date();
                const firstDayOfCurrentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                const lastDayOfCurrentMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);

                startDateInput.value = formatForInput(firstDayOfCurrentMonth);
                endDateInput.value = formatForInput(lastDayOfCurrentMonth);
            }
            
            // --- UI Settings Persistence ---
            const rateTypeSelector = document.getElementById('rateTypeSelector');
            const flatRateSection = document.getElementById('flatRateSection');
            const touRateSection = document.getElementById('touRateSection');

            const savedRateType = localStorage.getItem('rateType') || 'flat';
            document.querySelector(`input[name="rateType"][value="${savedRateType}"]`).checked = true;
            if (savedRateType === 'tou') {
                flatRateSection.classList.add('hidden');
                touRateSection.classList.remove('hidden');
            }

            document.getElementById('otherSupplierRate').value = localStorage.getItem('flatRate') || '36';
            document.getElementById('otherSupplierFeedInRateFlat').value = localStorage.getItem('flatFeedInRate') || '5';
            document.getElementById('dailyConnectionRate').value = localStorage.getItem('dailyConnectionRate') || '102.83';
            
            const savedTouRates = localStorage.getItem('touRates');
            if (savedTouRates) {
                const rates = JSON.parse(savedTouRates);
                document.getElementById('tou_peak_rate').value = rates.peak;
                document.getElementById('tou_shoulder_rate').value = rates.shoulder;
                document.getElementById('tou_offpeak_rate').value = rates.offpeak;
                document.getElementById('tou_controlled_load_rate').value = rates.controlledLoad;
                document.getElementById('otherSupplierFeedInRateTou').value = rates.feedIn;
            }
            
            rateTypeSelector.addEventListener('change', (e) => {
                localStorage.setItem('rateType', e.target.value);
                flatRateSection.classList.toggle('hidden', e.target.value === 'tou');
                touRateSection.classList.toggle('hidden', e.target.value !== 'tou');
            });
            
            document.getElementById('otherSupplierRate').addEventListener('input', (e) => localStorage.setItem('flatRate', e.target.value));
            document.getElementById('otherSupplierFeedInRateFlat').addEventListener('input', (e) => localStorage.setItem('flatFeedInRate', e.target.value));
            document.getElementById('dailyConnectionRate').addEventListener('input', (e) => localStorage.setItem('dailyConnectionRate', e.target.value));
            
            function saveTouSettings() {
                const rates = {
                    peak: document.getElementById('tou_peak_rate').value,
                    shoulder: document.getElementById('tou_shoulder_rate').value,
                    offpeak: document.getElementById('tou_offpeak_rate').value,
                    controlledLoad: document.getElementById('tou_controlled_load_rate').value,
                    feedIn: document.getElementById('otherSupplierFeedInRateTou').value
                };
                localStorage.setItem('touRates', JSON.stringify(rates));
            }
            ['tou_peak_rate', 'tou_shoulder_rate', 'tou_offpeak_rate', 'tou_controlled_load_rate', 'otherSupplierFeedInRateTou'].forEach(id => {
                document.getElementById(id).addEventListener('input', saveTouSettings);
            });

            // --- Supplier Details Toggle ---
            const toggleBtn = document.getElementById('toggleSupplierDetailsBtn');
            const supplierDetailsContainer = document.getElementById('otherSupplierDetailsContainer');

            const supplierDetailsVisible = localStorage.getItem('supplierDetailsVisible') === 'true';
            supplierDetailsContainer.classList.toggle('hidden', !supplierDetailsVisible);
            toggleBtn.textContent = supplierDetailsVisible ? 'Hide' : 'Show';

            toggleBtn.addEventListener('click', () => {
                const isHidden = supplierDetailsContainer.classList.toggle('hidden');
                toggleBtn.textContent = isHidden ? 'Show' : 'Hide';
                localStorage.setItem('supplierDetailsVisible', !isHidden);
            });

            // --- Main Buttons ---
            document.getElementById('downloadCsvButton').addEventListener('click', generateAndDownloadCSV);
            document.getElementById('showGraphButton').addEventListener('click', display24hrAverageGraph);
            
            // Initialize IndexedDB on load
            initDB().catch(err => console.error("Failed to initialize DB:", err));
        });

        // --- Main Fetch, Cache, and Calculation Logic ---
        document.getElementById('fetchData').addEventListener('click', async () => {
            const resultsSection = document.getElementById('resultsSection');
            const messageSection = document.getElementById('messageSection');
            const messageEl = document.getElementById('message');
            const loader = document.getElementById('loader');
            const resultsOutput = document.getElementById('results-output');
            const downloadCsvButton = document.getElementById('downloadCsvButton');
            const showGraphButton = document.getElementById('showGraphButton');
            const graphContainer = document.getElementById('graphContainer');
            const dailyGraphSection = document.getElementById('dailyGraphSection');

            resultsSection.classList.add('hidden');
            graphContainer.classList.add('hidden');
            dailyGraphSection.classList.add('hidden');
            downloadCsvButton.disabled = true;
            showGraphButton.disabled = true;
            resultsOutput.innerHTML = '';
            messageEl.textContent = '';

            const apiKey = document.getElementById('apiKey').value;
            const startDateValue = document.getElementById('startDate').value;
            const endDateValue = document.getElementById('endDate').value;
            
            if (!apiKey || !startDateValue || !endDateValue) {
                messageSection.classList.remove('hidden');
                messageEl.textContent = 'Please enter your API key and select a start and end date.';
                return;
            }
            
            localStorage.setItem('amberApiKey', apiKey);
            localStorage.setItem('startDate', startDateValue);
            localStorage.setItem('endDate', endDateValue);
            
            const overallStartDate = new Date(startDateValue + 'T00:00:00');
            const overallEndDate = new Date(endDateValue + 'T00:00:00');

            if (overallEndDate < overallStartDate) {
                messageSection.classList.remove('hidden');
                messageEl.textContent = 'End date cannot be before the start date.';
                return;
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayStr = formatForInput(today);
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const yesterdayStr = formatForInput(yesterday);
            const dbyesterday = new Date(today);
            dbyesterday.setDate(today.getDate() - 2);
            const dbyesterdayStr = formatForInput(dbyesterday);

            const allDatesInSelectedRange = [];
            let loopDate = new Date(overallStartDate);
            while(loopDate <= overallEndDate) {
                allDatesInSelectedRange.push(formatForInput(loopDate));
                loopDate.setDate(loopDate.getDate() + 1);
            }
            
            const datesToProcess = allDatesInSelectedRange.filter(d => new Date(d + "T00:00:00") <= today);
            const futureDatesCount = allDatesInSelectedRange.length - datesToProcess.length;

            messageSection.classList.remove('hidden');
            loader.classList.remove('hidden');
            messageEl.innerHTML = `<p>Processing ${datesToProcess.length} days...</p>`;

            try {
                // 1. Check Cache for the valid dates
                const cachedResults = await getDataFromCache(datesToProcess);
                const availableCachedDates = Object.keys(cachedResults);

                // 2. Determine which dates to fetch/refresh
                const datesToFetch = datesToProcess.filter(d =>
                    d === todayStr ||                  // It's today
                    d === yesterdayStr ||              // It's yesterday
                    d === dbyesterdayStr ||            // It's day before yesterday
                    !availableCachedDates.includes(d)  // It's not in the cache
                );
                const datesFromCache = datesToProcess.filter(d => !datesToFetch.includes(d));

                // 3. Display enhanced Cache Status
                let cacheStatusHTML = `<p class="text-lg font-medium">Range: ${startDateValue} to ${endDateValue}</p>`;
                if (futureDatesCount > 0) cacheStatusHTML += `<p class="text-gray-500">⚪ Skipping ${futureDatesCount} future day(s).</p>`;
                if (datesFromCache.length > 0) cacheStatusHTML += `<p class="text-green-600">✅ Using cache for ${datesFromCache.length} days.</p>`;
                
                const refreshCount = datesToFetch.filter(d => d === todayStr || d === yesterdayStr || d === dbyesterdayStr).length;
                if (refreshCount > 0) cacheStatusHTML += `<p class="text-yellow-600">🔄 Refreshing ${refreshCount} recent day(s).</p>`;
                
                const newDownloadCount = datesToFetch.filter(d => d !== todayStr && d !== yesterdayStr && d !== dbyesterdayStr).length;
                if (newDownloadCount > 0) cacheStatusHTML += `<p class="text-blue-600">⬇️ Downloading ${newDownloadCount} new day(s).</p>`;
                
                if (datesToFetch.length === 0 && datesToProcess.length > 0) cacheStatusHTML += `<p>All data loaded from local cache.</p>`;
                messageEl.innerHTML = cacheStatusHTML;

                // 4. Fetch from API if needed
                let newlyFetchedData = {};
                if (datesToFetch.length > 0) {
                    const siteDetails = await getSiteDetails(apiKey);
                    newlyFetchedData = await fetchUsageFromApi(apiKey, siteDetails.id, siteDetails.channels, datesToFetch);
                    
                    // 5. Save to cache, excluding today and yesterday
                    const dataToSave = Object.keys(newlyFetchedData)
                        .filter(date => date !== todayStr && date !== yesterdayStr && date !== dbyesterdayStr)
                        .map(date => ({ date: date, channels: newlyFetchedData[date] }));

                    if (dataToSave.length > 0) {
                        await saveDataToCache(dataToSave);
                    }
                }

                // 6. Combine and Aggregate Data
                messageEl.textContent = 'Combining data and calculating costs...';
                const combinedDataByDay = { ...cachedResults, ...newlyFetchedData };
                
                const masterChannelTotals = {};
                Object.values(combinedDataByDay).forEach(dayData => {
                    if (!dayData) return;
                    Object.values(dayData).forEach(channelInfo => {
                        if (channelInfo && channelInfo.identifier && !masterChannelTotals[channelInfo.identifier]) {
                             masterChannelTotals[channelInfo.identifier] = {
                                identifier: channelInfo.identifier, type: channelInfo.type,
                                totalKWh: 0, totalAmberCost: 0, totalCents: 0, count: 0, usageData: []
                            };
                        }
                    });
                });

                datesToProcess.forEach(date => {
                    const dayData = combinedDataByDay[date];
                    if (!dayData) return;
                    Object.keys(dayData).forEach(channelId => {
                        if(masterChannelTotals[channelId]) {
                            const { totalKWh, totalAmberCost, totalCents, count, usageData } = dayData[channelId];
                            masterChannelTotals[channelId].totalKWh += totalKWh;
                            masterChannelTotals[channelId].totalAmberCost += totalAmberCost;
                            masterChannelTotals[channelId].totalCents += totalCents;
                            masterChannelTotals[channelId].count += count;
                            masterChannelTotals[channelId].usageData.push(...usageData);
                        }
                    });
                });
                
                Object.values(masterChannelTotals).forEach(c => c.usageData.sort((a, b) => new Date(a.nemTime) - new Date(b.nemTime)));
                
                // 7. Run calculations and display
                cachedChannelData = JSON.parse(JSON.stringify(masterChannelTotals));
                lastFetchedStartDate = startDateValue;
                lastFetchedEndDate = endDateValue;

                calculateOtherSupplierCosts(cachedChannelData);
                
                const numDays = datesToProcess.length;
                const amberDailyCosts = (AMBER_CONNECTION_COST_PER_DAY_CENTS + AMBER_SUBSCRIPTION_COST_PER_DAY_CENTS) * numDays;
                const otherDailyConnection = (parseFloat(document.getElementById('dailyConnectionRate').value) || 0) * numDays;
                const demandTariffInfo = calculateDemandTariff(cachedChannelData);
                const demandTariffCost = demandTariffInfo.cost;
                
                const { totalAmber: overallAmberCost, totalOther: overallOtherCost } = Object.values(cachedChannelData).reduce((acc, c) => ({
                    totalAmber: acc.totalAmber + c.totalAmberCost,
                    totalOther: acc.totalOther + c.totalOtherCost
                }), { totalAmber: 0, totalOther: 0 });

                const finalAmberCost = overallAmberCost + (demandTariffCost + amberDailyCosts / 100);
                const finalOtherCost = overallOtherCost + (otherDailyConnection / 100);

                loader.classList.add('hidden');
                messageSection.classList.add('hidden');
                resultsSection.classList.remove('hidden');
                displayResults(cachedChannelData, finalAmberCost, finalOtherCost, startDateValue, endDateValue, numDays, demandTariffInfo);

            } catch (error) {
                console.error('Error:', error);
                cachedChannelData = null;
                loader.classList.add('hidden');
                messageEl.innerHTML = `Error: ${error.message}`;
            }
        });

        // --- API Fetching Helpers ---
        async function getSiteDetails(apiKey) {
            const headers = { 'Authorization': `Bearer ${apiKey}`, 'accept': 'application/json' };
            const sitesResponse = await fetch(`${AMBER_API_URL}/sites`, { headers });
            const responseText = await sitesResponse.text();

            if (!sitesResponse.ok) {
                let detail = `Status ${sitesResponse.status}: ${sitesResponse.statusText}`;
                 try {
                    const errorJson = JSON.parse(responseText);
                    detail = errorJson.message || responseText;
                } catch (e) {
                    detail = responseText || detail;
                }

                if (sitesResponse.status === 403) throw new Error(`Authentication failed. API Key may be invalid. <br>Reason: ${detail}`);
                throw new Error(`Failed to fetch site details. <br>Reason: ${detail}`);
            }
            const sites = JSON.parse(responseText);
            if (!sites || sites.length === 0) throw new Error('No sites found for this API key.');
            const site = sites[0];
            if (!site.channels || site.channels.length === 0) throw new Error('No channels found for this site.');
            return { id: site.id, channels: site.channels };
        }

        async function fetchUsageFromApi(apiKey, siteId, channels, datesToFetch) {
            const headers = { 'Authorization': `Bearer ${apiKey}`, 'accept': 'application/json' };
            const messageEl = document.getElementById('message');
            const allFetchedData = {}; // Structured as { 'YYYY-MM-DD': { 'channelId': {...} } }

            // Pre-initialize all dates to ensure they get an entry in the cache, even if no data is returned.
            datesToFetch.forEach(date => {
                allFetchedData[date] = {};
            });

            const dateChunks = [];
            // The API returns an error for date ranges of 7 days, stating it's too large.
            // To fix this, we'll fetch data in smaller chunks of 6 days. This increases
            // the number of API requests slightly but ensures each request is within the valid range.
            const MAX_DAYS_PER_REQUEST = 6;
            for (let i = 0; i < datesToFetch.length; i += MAX_DAYS_PER_REQUEST) {
                dateChunks.push(datesToFetch.slice(i, i + MAX_DAYS_PER_REQUEST));
            }

            for (const chunk of dateChunks) {
                const startDateStr = chunk[0];
                const endDateStr = chunk[chunk.length - 1];

                for (const channel of channels) {
                    const channelId = channel.identifier;
                    messageEl.innerHTML += `<p class="text-sm italic">Fetching ${channelId} for ${startDateStr} to ${endDateStr}...</p>`;
                    
                    const usageUrl = `${AMBER_API_URL}/sites/${siteId}/usage?startDate=${startDateStr}&endDate=${endDateStr}&channel=${channelId}`;
                    const usageResponse = await fetch(usageUrl, { headers });
                    const responseText = await usageResponse.text();

                    if (!usageResponse.ok) {
                        let detail = `Status ${usageResponse.status}: ${usageResponse.statusText}`;
                        try {
                            const errorJson = JSON.parse(responseText);
                            detail = errorJson.message || responseText;
                        } catch (e) {
                            detail = responseText || detail;
                        }
                         throw new Error(`Failed to fetch usage for channel <strong>${channelId}</strong> from <strong>${startDateStr}</strong> to <strong>${endDateStr}</strong>. <br>Reason: ${detail}`);
                    }
                    
                    const usageDataForPeriod = JSON.parse(responseText);
                    
                    if (usageDataForPeriod && usageDataForPeriod.length > 0) {
                        usageDataForPeriod.forEach(item => {
                            if (item.channelIdentifier !== channelId) return;

                            const itemDate = new Date(item.nemTime);
                            itemDate.setMinutes(itemDate.getMinutes() - 5);
                            const itemDateStr = formatForInput(itemDate);
                            item.nemTime = toLocalIsoWithOffset(itemDate);

                            if (!allFetchedData[itemDateStr]) allFetchedData[itemDateStr] = {};
                            if (!allFetchedData[itemDateStr][channelId]) {
                                allFetchedData[itemDateStr][channelId] = {
                                    identifier: channel.identifier, type: channel.type,
                                    totalKWh: 0, totalAmberCost: 0, totalCents: 0, count: 0, usageData: []
                                };
                            }
                            
                            const dayChannelData = allFetchedData[itemDateStr][channelId];
                            const kwh = parseFloat(item.kwh) || 0;
                            const perKwh = parseFloat(item.perKwh) || 0;
                            dayChannelData.totalKWh += kwh;
                            dayChannelData.totalAmberCost += (perKwh / 100) * kwh;
                            dayChannelData.usageData.push(item);
                            dayChannelData.totalCents += perKwh;
                            dayChannelData.count += 1;
                        });
                    }
                }
            }
            return allFetchedData;
        }

        // --- Calculation and Display Functions (Largely Unchanged) ---
        
        function generateAndDownloadCSV() {
            if (!cachedChannelData) {
                // Using a simple message for now, as custom modals add complexity.
                console.warn("No data available to export. Please fetch data first.");
                return;
            }
            let csvContent = "nemTime,channelIdentifier,kWh,SpotPrice_cents_per_kWh\n";
            Object.values(cachedChannelData).forEach(channel => {
                if (!channel.usageData) return;
                channel.usageData.forEach(item => {
                    csvContent += `"${item.nemTime || ''}",${channel.identifier},${item.kwh || ''},${item.perKwh || ''}\n`;
                });
            });
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `amber_usage_${lastFetchedStartDate}_to_${lastFetchedEndDate}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function getTouRate(date, rates) {
            const day = date.getDay();
            const hour = date.getHours();
            const isWeekday = day >= 1 && day <= 5;
            if (hour >= 22 || hour < 7) return rates.offpeak;
            if (isWeekday) return (hour >= 14 && hour < 20) ? rates.peak : rates.shoulder;
            return rates.shoulder;
        }
        
        function calculateOtherSupplierCosts(channelTotals) {
            const rateType = document.querySelector('input[name="rateType"]:checked').value;
            if (rateType === 'flat') {
                const otherRate = parseFloat(document.getElementById('otherSupplierRate').value) || 0;
                const feedInRate = parseFloat(document.getElementById('otherSupplierFeedInRateFlat').value) || 0;
                Object.values(channelTotals).forEach(c => {
                    c.totalOtherCost = c.type === 'feedIn' ? -1 * (c.totalKWh * feedInRate) / 100 : (c.totalKWh * otherRate) / 100;
                });
            } else {
                const touRates = {
                    peak: parseFloat(document.getElementById('tou_peak_rate').value) || 0,
                    shoulder: parseFloat(document.getElementById('tou_shoulder_rate').value) || 0,
                    offpeak: parseFloat(document.getElementById('tou_offpeak_rate').value) || 0
                };
                const feedInRate = parseFloat(document.getElementById('otherSupplierFeedInRateTou').value) || 0;
                const controlledLoadRate = parseFloat(document.getElementById('tou_controlled_load_rate').value) || 0;
                Object.values(channelTotals).forEach(c => {
                    if (c.type === 'feedIn') c.totalOtherCost = -1 * (c.totalKWh * feedInRate) / 100;
                    else if (c.type === 'controlledLoad') c.totalOtherCost = (c.totalKWh * controlledLoadRate) / 100;
                    else {
                        c.totalOtherCost = c.usageData.reduce((total, item) => {
                            return total + ((parseFloat(item.kwh) || 0) * getTouRate(new Date(item.nemTime), touRates) / 100);
                        }, 0);
                    }
                });
            }
        }
        
        function calculateDemandTariff(channelTotals) {
            const generalChannel = Object.values(cachedChannelData).find(c => c.type === 'general');
            if (!generalChannel || !generalChannel.usageData || generalChannel.usageData.length === 0) return { cost: 0, maxDemandKwh: 0, demandDays: 0, maxDemandTime: null };
            const demandWindowUsage = generalChannel.usageData.filter(item => item.tariffInformation?.demandWindow);
            if (demandWindowUsage.length === 0) return { cost: 0, maxDemandKwh: 0, demandDays: 0, maxDemandTime: null };

            const thirtyMinChunks = demandWindowUsage.reduce((acc, item) => {
                const itemDate = new Date(item.nemTime);
                itemDate.setMinutes(itemDate.getMinutes() < 30 ? 0 : 30, 0, 0);
                const blockStartTime = itemDate.toISOString();
                acc[blockStartTime] = (acc[blockStartTime] || 0) + (parseFloat(item.kwh) || 0);
                return acc;
            }, {});

            const [maxDemandTime, maxDemandKwh] = Object.entries(thirtyMinChunks).reduce((max, curr) => curr[1] > max[1] ? curr : max, [null, 0]);
            if (maxDemandKwh === 0) return { cost: 0, maxDemandKwh: 0, demandDays: 0, maxDemandTime: null };
            
            const numberOfDemandDays = new Set(demandWindowUsage.map(item => item.nemTime.substring(0, 10))).size;
            const demandTariffCost = maxDemandKwh * 2 * (AMBER_DEMAND_TARIFF_COST_PER_KW_CENTS / 100) * numberOfDemandDays;

            return { cost: demandTariffCost, maxDemandKwh: maxDemandKwh, demandDays: numberOfDemandDays, maxDemandTime: maxDemandTime };
        }

        // --- Charting and Display Functions (Unchanged from original logic) ---
        function display24hrAverageGraph() {
             const graphContainer = document.getElementById('graphContainer');
            const showGraphButton = document.getElementById('showGraphButton');

            if (graphContainer.classList.contains('hidden')) {
                graphContainer.classList.remove('hidden');
                showGraphButton.textContent = 'Hide Avg Graph';
            } else {
                graphContainer.classList.add('hidden');
                showGraphButton.textContent = 'Show 24hr Avg Graph';
                return;
            }

            if (!cachedChannelData) {
                graphContainer.innerHTML = '<p class="text-center text-red-500">No data available to render graph.</p>';
                return;
            }
            const generalChannel = Object.values(cachedChannelData).find(c => c.type === 'general');
            const feedInChannel = Object.values(cachedChannelData).find(c => c.type === 'feedIn');
            const controlledLoadChannel = Object.values(cachedChannelData).find(c => c.type === 'controlledLoad');

            if (!generalChannel || !generalChannel.usageData || generalChannel.usageData.length === 0) {
                 graphContainer.innerHTML = '<p class="text-center text-red-500">No general usage data found to render graph.</p>';
                return;
            }

            const intervals = Array.from({ length: 48 }, () => ({ totalKwh: 0, totalCents: 0, count: 0 }));
            
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            const numDays = Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;

            generalChannel.usageData.forEach(item => {
                const nemTimeStr = item.nemTime;
                const hours = parseInt(nemTimeStr.substring(11, 13));
                const minutes = parseInt(nemTimeStr.substring(14, 16));
                const intervalIndex = hours * 2 + Math.floor(minutes / 30);
                
                if (intervals[intervalIndex]) {
                    intervals[intervalIndex].totalKwh += (parseFloat(item.kwh) || 0);
                    intervals[intervalIndex].totalCents += (parseFloat(item.perKwh) || 0);
                    intervals[intervalIndex].count += 1;
                }
            });

            const feedInIntervals = Array.from({ length: 48 }, () => ({ totalKwh: 0 }));
            if (feedInChannel && feedInChannel.usageData) {
                feedInChannel.usageData.forEach(item => {
                    const nemTimeStr = item.nemTime;
                    const hours = parseInt(nemTimeStr.substring(11, 13));
                    const minutes = parseInt(nemTimeStr.substring(14, 16));
                    const intervalIndex = hours * 2 + Math.floor(minutes / 30);
                    
                    if (feedInIntervals[intervalIndex]) {
                        feedInIntervals[intervalIndex].totalKwh += (parseFloat(item.kwh) || 0);
                    }
                });
            }
            
            const controlledLoadIntervals = Array.from({ length: 48 }, () => ({ totalKwh: 0 }));
            if (controlledLoadChannel && controlledLoadChannel.usageData) {
                controlledLoadChannel.usageData.forEach(item => {
                    const nemTimeStr = item.nemTime;
                    const hours = parseInt(nemTimeStr.substring(11, 13));
                    const minutes = parseInt(nemTimeStr.substring(14, 16));
                    const intervalIndex = hours * 2 + Math.floor(minutes / 30);

                    if (controlledLoadIntervals[intervalIndex]) {
                        controlledLoadIntervals[intervalIndex].totalKwh += (parseFloat(item.kwh) || 0);
                    }
                });
            }

            const labels = Array.from({ length: 48 }, (_, i) => `${Math.floor(i / 2).toString().padStart(2, '0')}:${(i % 2) * 30 === 0 ? '00' : '30'}`);
            
            const avgUsageData = intervals.map(i => numDays > 0 ? (i.totalKwh / numDays) * 2 : 0);
            const avgFeedInData = feedInIntervals.map(i => numDays > 0 ? (-i.totalKwh / numDays) * 2 : 0);
            const avgControlledLoadData = controlledLoadIntervals.map(i => numDays > 0 ? (i.totalKwh / numDays) * 2 : 0);
            const avgPriceData = intervals.map(i => i.count > 0 ? (i.totalCents / i.count) : 0);

            const ctx = document.getElementById('usagePriceChart').getContext('2d');
            
            if (usageChart) usageChart.destroy();
            
            const chartDatasets = [];
            const avgDailyGeneralKwh = (generalChannel?.totalKWh || 0) / numDays;
            const avgDailyFeedInKwh = (feedInChannel?.totalKWh || 0) / numDays;
            const avgDailyControlledLoadKwh = (controlledLoadChannel?.totalKWh || 0) / numDays;
            const generalAvgPrice = (generalChannel?.totalKWh > 0 ? ((generalChannel.totalAmberCost * 100) / generalChannel.totalKWh) : 0).toFixed(2);
            const feedInAvgPrice = (feedInChannel?.totalKWh > 0 ? ((-feedInChannel.totalAmberCost * 100) / feedInChannel.totalKWh) : 0).toFixed(2);
            const controlledLoadAvgPrice = (controlledLoadChannel?.totalKWh > 0 ? ((controlledLoadChannel.totalAmberCost * 100) / controlledLoadChannel.totalKWh) : 0).toFixed(2);

            if (controlledLoadChannel && (controlledLoadChannel.totalKWh || 0) > 0) {
                chartDatasets.push({
                    label: `Avg Controlled Load (kW) - Total: ${avgDailyControlledLoadKwh.toFixed(2)} kWh, Price: ${controlledLoadAvgPrice} c/kWh`,
                    data: avgControlledLoadData, backgroundColor: 'rgba(13, 110, 253, 0.6)', yAxisID: 'yUsage', order: 2
                });
            }
            chartDatasets.push({
                label: `Avg Usage (kW) - Total: ${avgDailyGeneralKwh.toFixed(2)} kWh, Price: ${generalAvgPrice} c/kWh`,
                data: avgUsageData, backgroundColor: 'rgba(54, 162, 235, 0.6)', yAxisID: 'yUsage', order: 2
            });
            if (feedInChannel) {
                chartDatasets.push({
                    label: `Avg Feed-in (kW) - Total: ${avgDailyFeedInKwh.toFixed(2)} kWh, Price: ${feedInAvgPrice} c/kWh`,
                    data: avgFeedInData, backgroundColor: 'rgba(40, 167, 69, 0.6)', yAxisID: 'yUsage', order: 2
                });
            }
            chartDatasets.push({
                label: 'Avg Spot Price (c/kWh)', data: avgPriceData, type: 'line', borderColor: 'rgba(255, 99, 132, 1)',
                fill: false, yAxisID: 'yPrice', order: 1
            });

            const allUsage = [...avgUsageData, ...avgFeedInData, ...avgControlledLoadData];
            const usageMin = Math.min(...allUsage);
            const usageMax = Math.max(...allUsage);
            const priceMax = Math.max(...avgPriceData.filter(p => p !== null));
            let priceAxisOptions = { type: 'linear', display: true, position: 'right', title: { display: true, text: 'Avg Spot Price (c/kWh)' }, grid: { drawOnChartArea: false } };
            if (usageMin < 0 && usageMax > 0 && priceMax > 0) {
                const ratio = -usageMin / (usageMax - usageMin);
                priceAxisOptions.min = Math.floor(((ratio * priceMax) / (ratio - 1)) / 5) * 5;
                priceAxisOptions.max = Math.ceil(priceMax / 5) * 5;
            }

            usageChart = new Chart(ctx, {
                type: 'bar', data: { labels: labels, datasets: chartDatasets },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { stacked: true, ticks: { callback: (v, i) => i % 4 === 0 ? labels[i] : (i === labels.length - 1 ? '24:00' : ''), autoSkip: false, maxRotation: 45, minRotation: 45 },
                            grid: { color: c => c.index % 2 === 0 ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)' } },
                        yUsage: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Avg Power (kW)' }, stacked: true },
                        yPrice: priceAxisOptions
                    },
                    plugins: {
                        title: { display: true, text: `Avg 24-Hour Usage vs. Spot Price (${document.getElementById('startDate').value} to ${document.getElementById('endDate').value})`},
                        tooltip: { position: 'cursor', callbacks: { label: c => c.dataset.yAxisID === 'yPrice' ? `Price: ${parseFloat(c.parsed.y).toFixed(2)} c/kWh` : `Usage: ${parseFloat(c.parsed.y).toFixed(4)} kW` } }
                    }
                }
            });
        }
        
        function displayDailyGraph(selectedDateStr) {
            if (!cachedChannelData) return;

            const chartContainer = document.getElementById('dailyChart').parentElement;
            if (dailyUsageChart) {
                dailyUsageChart.destroy();
            }
            // Reset the container to clear any previous messages and recreate the canvas
            chartContainer.innerHTML = '<canvas id="dailyChart"></canvas>';

            const generalChannel = Object.values(cachedChannelData).find(c => c.type === 'general');
            const feedInChannel = Object.values(cachedChannelData).find(c => c.type === 'feedIn');
            const controlledLoadChannel = Object.values(cachedChannelData).find(c => c.type === 'controlledLoad');

            const dayData = generalChannel?.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr) || [];
            const dayDataFeedIn = feedInChannel?.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr) || [];
            const dayDataControlled = controlledLoadChannel?.usageData.filter(item => item.nemTime.substring(0, 10) === selectedDateStr) || [];

            // If there's no data for any channel on this day, show a message and stop.
            if (dayData.length === 0 && dayDataFeedIn.length === 0 && dayDataControlled.length === 0) {
                const noDataMessage = document.createElement('div');
                noDataMessage.className = "absolute inset-0 flex items-center justify-center text-gray-500 bg-gray-50 rounded-lg";
                noDataMessage.innerHTML = `<p>No usage data recorded for this day.</p>`;
                chartContainer.appendChild(noDataMessage);
                return;
            }

            const intervals = Array.from({ length: 288 }, () => ({ kwh: 0, price: null, count: 0 }));
            dayData.forEach(item => {
                const i = parseInt(item.nemTime.substring(11, 13)) * 12 + Math.floor(parseInt(item.nemTime.substring(14, 16)) / 5);
                if(intervals[i]) { intervals[i].kwh += parseFloat(item.kwh) || 0; intervals[i].price = (intervals[i].price || 0) + (parseFloat(item.perKwh) || 0); intervals[i].count += 1; }
            });
            const feedInIntervals = Array.from({ length: 288 }, () => ({ kwh: 0 }));
            dayDataFeedIn.forEach(item => {
                const i = parseInt(item.nemTime.substring(11, 13)) * 12 + Math.floor(parseInt(item.nemTime.substring(14, 16)) / 5);
                if (feedInIntervals[i]) feedInIntervals[i].kwh += parseFloat(item.kwh) || 0;
            });
            const controlledLoadIntervals = Array.from({ length: 288 }, () => ({ kwh: 0 }));
            dayDataControlled.forEach(item => {
                const i = parseInt(item.nemTime.substring(11, 13)) * 12 + Math.floor(parseInt(item.nemTime.substring(14, 16)) / 5);
                if (controlledLoadIntervals[i]) controlledLoadIntervals[i].kwh += parseFloat(item.kwh) || 0;
            });

            const labels = intervals.map((_, i) => `${Math.floor(i / 12).toString().padStart(2, '0')}:${((i % 12) * 5).toString().padStart(2, '0')}`);
            const usageData = intervals.map(i => i.kwh * 12);
            const feedInData = feedInIntervals.map(i => -i.kwh * 12);
            const controlledLoadData = controlledLoadIntervals.map(i => i.kwh * 12);
            const priceData = intervals.map(i => i.count > 0 ? i.price / i.count : null);
            
            const ctx = document.getElementById('dailyChart').getContext('2d');
            
            const chartDatasets = [];
            
            const sumKwh = data => data.reduce((t, i) => t + (parseFloat(i.kwh) || 0), 0);
            const sumCost = data => data.reduce((t, i) => t + ((parseFloat(i.perKwh) || 0) / 100) * (parseFloat(i.kwh) || 0), 0);
            const dailyGeneralKwh = sumKwh(dayData), dailyFeedInKwh = sumKwh(dayDataFeedIn), dailyControlledLoadKwh = sumKwh(dayDataControlled);
            const dailyGeneralAvgPrice = (dailyGeneralKwh > 0 ? (sumCost(dayData) / dailyGeneralKwh) * 100 : 0).toFixed(2);
            const dailyFeedInAvgPrice = (dailyFeedInKwh > 0 ? ((-sumCost(dayDataFeedIn)) / dailyFeedInKwh) * 100 : 0).toFixed(2);
            const dailyControlledLoadAvgPrice = (dailyControlledLoadKwh > 0 ? (sumCost(dayDataControlled) / dailyControlledLoadKwh) * 100 : 0).toFixed(2);

            if (dailyControlledLoadKwh > 0) chartDatasets.push({ label: `Controlled Load (kW) - Total: ${dailyControlledLoadKwh.toFixed(2)} kWh, Avg Price: ${dailyControlledLoadAvgPrice} c/kWh`, data: controlledLoadData, backgroundColor: 'rgba(13, 110, 253, 0.6)', yAxisID: 'yUsage', order: 2 });
            if (dailyGeneralKwh > 0) chartDatasets.push({ label: `Usage (kW) - Total: ${dailyGeneralKwh.toFixed(2)} kWh, Avg Price: ${dailyGeneralAvgPrice} c/kWh`, data: usageData, backgroundColor: 'rgba(54, 162, 235, 0.6)', yAxisID: 'yUsage', order: 2 });
            if (dailyFeedInKwh > 0) chartDatasets.push({ label: `Feed-in (kW) - Total: ${dailyFeedInKwh.toFixed(2)} kWh, Avg Price: ${dailyFeedInAvgPrice} c/kWh`, data: feedInData, backgroundColor: 'rgba(40, 167, 69, 0.6)', yAxisID: 'yUsage', order: 2 });
            
            if (dailyGeneralKwh > 0) {
                chartDatasets.push({ label: 'Spot Price (c/kWh)', data: priceData, type: 'line', borderColor: 'rgba(255, 99, 132, 1)', pointRadius: 0, borderWidth: 2, fill: false, yAxisID: 'yPrice', order: 1, spanGaps: true, });
            }
            
            const allUsage = [...usageData, ...feedInData, ...controlledLoadData];
            const usageMin = Math.min(...allUsage), usageMax = Math.max(...allUsage), priceMax = Math.max(...priceData.filter(p => p !== null));
            let priceAxisOptions = { type: 'linear', display: true, position: 'right', title: { display: true, text: 'Spot Price (c/kWh)' }, grid: { drawOnChartArea: false }, };
            if (usageMin < 0 && usageMax > 0 && priceMax > 0) { const ratio = -usageMin / (usageMax - usageMin); priceAxisOptions.min = Math.floor(((ratio * priceMax) / (ratio - 1)) / 5) * 5; priceAxisOptions.max = Math.ceil(priceMax / 5) * 5; }

            dailyUsageChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: chartDatasets },
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { stacked: true, ticks: { callback: (v, i) => i % 24 === 0 ? labels[i] : '', autoSkip: false, maxRotation: 45, minRotation: 45 }, grid: { color: c => c.index % 12 === 0 ? 'rgba(0,0,0,0.2)' : (c.index % 6 === 0 ? 'rgba(0,0,0,0.05)' : 'transparent') } },
                        yUsage: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Power (kW)' }, stacked: true, },
                        yPrice: priceAxisOptions
                    },
                    plugins: { title: { display: true, text: `Usage vs. Spot Price for ${selectedDateStr}` }, tooltip: { position: 'cursor', callbacks: { label: c => c.dataset.yAxisID === 'yPrice' ? `Price: ${parseFloat(c.parsed.y).toFixed(2)} c/kWh` : `Usage: ${parseFloat(c.parsed.y).toFixed(4)} kW` } } }
                }
            });
        }

        function displayResults(channelTotals, overallAmberCost, overallOtherCost, startDateStr, endDateStr, numDays, demandTariffInfo) {
            const resultsOutput = document.getElementById('results-output');
            const downloadCsvButton = document.getElementById('downloadCsvButton');
            const showGraphButton = document.getElementById('showGraphButton');
            const otherDailyConnection = (parseFloat(document.getElementById('dailyConnectionRate').value) || 0) * numDays;
            
            let tableHTML = `<p class="text-sm text-gray-500 mb-4">Period: (${startDateStr} to ${endDateStr}, ${numDays} days)</p>
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50"><tr>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Channel</th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Usage (kWh)</th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amber Cost</th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Other Supplier Cost</th>
                    </tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            
            Object.values(channelTotals).filter(c=>c.totalKWh !== 0 || c.totalAmberCost !== 0 || c.totalOtherCost !== 0).forEach(c => {
                tableHTML += `<tr>
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${c.identifier}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${c.type}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${(c.totalKWh || 0).toFixed(2)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$${(c.totalAmberCost || 0).toFixed(2)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$${(c.totalOtherCost || 0).toFixed(2)}</td></tr>`;
            });
            
            if (demandTariffInfo?.cost > 0) {
                const maxDemandKw = ((demandTariffInfo.maxDemandKwh || 0) * 2).toFixed(2);
                const maxDemandDateTime = new Date(demandTariffInfo.maxDemandTime).toLocaleString('en-AU', { dateStyle: 'short', timeStyle: 'short' });
                tableHTML += `<tr class="font-semibold border-t">
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" colspan="2">Demand Tariff</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        <div class="text-xs">Max: ${maxDemandKw} kW on ${maxDemandDateTime}</div>
                        <div class="text-xs">X ${demandTariffInfo.demandDays} days</div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">$${(demandTariffInfo.cost || 0).toFixed(2)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 italic">N/A?</td></tr>`;
            }
            tableHTML += `<tr class="font-semibold border-t">
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900" colspan="3">Daily Connection</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">$${(AMBER_CONNECTION_COST_PER_DAY_CENTS * numDays / 100).toFixed(2)}</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">$${(otherDailyConnection / 100).toFixed(2)}</td></tr>
                <tr class="font-semibold">
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900" colspan="3">Amber Subscription</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">$${(AMBER_SUBSCRIPTION_COST_PER_DAY_CENTS * numDays / 100).toFixed(2)}</td>
                    <td class="px-6 py-2 whitespace-nowrap text-sm text-gray-900">N/A</td></tr>
                <tr class="bg-gray-50 font-bold">
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900" colspan="3">Total</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">$${(overallAmberCost || 0).toFixed(2)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">$${(overallOtherCost || 0).toFixed(2)}</td>
                </tr></tbody></table>`;
            
            const savings = (overallOtherCost || 0) - (overallAmberCost || 0);
            const savingsClass = savings > 0 ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
            const savingsText = savings > 0 ? `You saved <span class="font-bold">$${savings.toFixed(2)}</span> with Amber!` : `It would have been <span class="font-bold">$${Math.abs(savings).toFixed(2)}</span> cheaper with the other supplier.`;
            resultsOutput.innerHTML = tableHTML + `<div class="mt-6 p-4 rounded-lg text-center ${savingsClass}"><p class="text-lg font-medium">${savingsText}</p></div>`;
            
            downloadCsvButton.disabled = false;
            showGraphButton.disabled = false;

            const dailyGraphSection = document.getElementById('dailyGraphSection');
            const daySelector = document.getElementById('daySelector');
            const prevDayBtn = document.getElementById('prevDayBtn');
            const nextDayBtn = document.getElementById('nextDayBtn');
            
            daySelector.innerHTML = '';
            
            const datesForSelector = allDatesInSelectedRange.filter(d => new Date(d + "T00:00:00") <= new Date(todayStr + "T00:00:00"));

            datesForSelector.forEach(dateValue => {
                daySelector.innerHTML += `<option value="${dateValue}">${dateValue}</option>`;
            });

            const updateNavButtons = () => {
                prevDayBtn.disabled = daySelector.selectedIndex === 0;
                nextDayBtn.disabled = daySelector.selectedIndex === daySelector.options.length - 1;
            };
            daySelector.onchange = () => { displayDailyGraph(daySelector.value); updateNavButtons(); };
            prevDayBtn.onclick = () => { if (daySelector.selectedIndex > 0) { daySelector.selectedIndex--; daySelector.dispatchEvent(new Event('change')); } };
            nextDayBtn.onclick = () => { if (daySelector.selectedIndex < daySelector.options.length - 1) { daySelector.selectedIndex++; daySelector.dispatchEvent(new Event('change')); } };
            
            if (daySelector.options.length > 0) {
                dailyGraphSection.classList.remove('hidden');
                daySelector.dispatchEvent(new Event('change'));
            } else {
                dailyGraphSection.classList.add('hidden');
            }
        }
    </script>
</body>
</html>
